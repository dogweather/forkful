---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:12:51.028714-07:00
description: "\u041A\u0430\u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\
  \u0430\u0442\u044C: \u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0438 \u0438\
  \u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0430\u0441\
  \u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445 \u043C\u0430\u0441\
  \u0441\u0438\u0432\u043E\u0432 \u0432 PowerShell \u0434\u043E\u0432\u043E\u043B\u044C\
  \u043D\u043E \u043F\u0440\u043E\u0441\u0442\u043E\u0435. \u0412\u043E\u0442 \u043A\
  \u0430\u043A \u044D\u0442\u043E \u0440\u0430\u0431\u043E\u0442\u0430\u0435\u0442\
  : **\u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0430\u0441\u0441\u043E\u0446\
  \u0438\u0430\u0442\u0438\u0432\u043D\u043E\u0433\u043E\u2026"
lastmod: '2024-03-13T22:44:45.433967-06:00'
model: gpt-4-0125-preview
summary: "\u0421\u043E\u0437\u0434\u0430\u043D\u0438\u0435 \u0438 \u0438\u0441\u043F\
  \u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435 \u0430\u0441\u0441\u043E\
  \u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445 \u043C\u0430\u0441\u0441\u0438\
  \u0432\u043E\u0432 \u0432 PowerShell \u0434\u043E\u0432\u043E\u043B\u044C\u043D\u043E\
  \ \u043F\u0440\u043E\u0441\u0442\u043E\u0435."
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
weight: 15
---

## Как использовать:
Создание и использование ассоциативных массивов в PowerShell довольно простое. Вот как это работает:

**Создание ассоциативного массива:**

```PowerShell
$myAssociativeArray = @{}
$myAssociativeArray["name"] = "Алекс"
$myAssociativeArray["age"] = 25
$myAssociativeArray["job"] = "Инженер"
```

Этот фрагмент кода создает ассоциативный массив с тремя парами ключ-значение.

**Доступ к значениям:**

Чтобы получить значение, укажите его ключ:

```PowerShell
Write-Output $myAssociativeArray["name"]
```

**Пример вывода:**

```
Алекс
```

**Добавление или изменение данных:**

Просто используйте ключ, чтобы добавить новую пару или изменить существующую:

```PowerShell
$myAssociativeArray["location"] = "Нью-Йорк" # Добавляет новую пару ключ-значение
$myAssociativeArray["job"] = "Старший инженер" # Изменяет существующую пару
```

**Итерация по ассоциативному массиву:**

Перебор ключей и значений выглядит так:

```PowerShell
foreach ($key in $myAssociativeArray.Keys) {
  $value = $myAssociativeArray[$key]
  Write-Output "$key : $value"
}
```

**Пример вывода:**

```
name : Алекс
age : 25
job : Старший инженер
location : Нью-Йорк
```

## Глубокое погружение
Концепция ассоциативных массивов общепринята во многих языках программирования, обычно называясь словарем, картой или хеш-таблицей в зависимости от языка. В PowerShell ассоциативные массивы реализованы как хеш-таблицы, которые довольно эффективны для поиска ключей, хранения данных и поддержания коллекции уникальных ключей.

Исторически ассоциативные массивы предоставляли средство для управления коллекциями объектов, где каждый элемент может быть быстро получен без итерации по всей коллекции с использованием его ключа. Эффективность извлечения и изменения данных в ассоциативных массивах делает их предпочтительным выбором для различных задач. Однако у них есть ограничения, такие как поддержание порядка, для которых упорядоченные словари или пользовательские объекты могут быть лучшей альтернативой.

Несмотря на их ограничения, ассоциативные массивы/хеш-таблицы в PowerShell невероятно гибки и мощный инструмент для скриптинга. Они позволяют динамически хранить данные и особенно полезны в настройках, манипуляциях с данными и везде, где нужен структурированный формат данных без накладных расходов определения формального класса. Просто помните, что хотя ассоциативные массивы идеально подходят для извлечения данных на основе ключа, если ваша задача включает в себя сложные структуры данных или требует поддержания определенного порядка, возможно, вам стоит рассмотреть другие типы данных или пользовательские объекты в PowerShell.
