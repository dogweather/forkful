---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:10:54.246101-07:00
description: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u043B\u0438 \u0445\u0435\
  \u0448-\u0442\u0430\u0431\u043B\u0438\u0446\u044B, \u0432 Clojure \u043F\u043E\u0437\
  \u0432\u043E\u043B\u044F\u044E\u0442 \u0432\u0430\u043C \u0445\u0440\u0430\u043D\
  \u0438\u0442\u044C \u0438 \u0438\u0437\u0432\u043B\u0435\u043A\u0430\u0442\u044C\
  \ \u0434\u0430\u043D\u043D\u044B\u0435 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\
  \u044E \u043F\u0430\u0440 \u043A\u043B\u044E\u0447-\u0437\u043D\u0430\u0447\u0435\
  \u043D\u0438\u0435. \u041E\u043D\u0438 \u044F\u0432\u043B\u044F\u044E\u0442\u0441\
  \u044F \u043E\u0441\u043D\u043E\u0432\u043D\u044B\u043C \u0438\u043D\u0441\u0442\
  \u0440\u0443\u043C\u0435\u043D\u0442\u043E\u043C\u2026"
lastmod: '2024-03-11T00:14:17.861372-06:00'
model: gpt-4-0125-preview
summary: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u043B\u0438 \u0445\u0435\
  \u0448-\u0442\u0430\u0431\u043B\u0438\u0446\u044B, \u0432 Clojure \u043F\u043E\u0437\
  \u0432\u043E\u043B\u044F\u044E\u0442 \u0432\u0430\u043C \u0445\u0440\u0430\u043D\
  \u0438\u0442\u044C \u0438 \u0438\u0437\u0432\u043B\u0435\u043A\u0430\u0442\u044C\
  \ \u0434\u0430\u043D\u043D\u044B\u0435 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\
  \u044E \u043F\u0430\u0440 \u043A\u043B\u044E\u0447-\u0437\u043D\u0430\u0447\u0435\
  \u043D\u0438\u0435. \u041E\u043D\u0438 \u044F\u0432\u043B\u044F\u044E\u0442\u0441\
  \u044F \u043E\u0441\u043D\u043E\u0432\u043D\u044B\u043C \u0438\u043D\u0441\u0442\
  \u0440\u0443\u043C\u0435\u043D\u0442\u043E\u043C\u2026"
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
---

{{< edit_this_page >}}

## Что и почему?

Ассоциативные массивы, или хеш-таблицы, в Clojure позволяют вам хранить и извлекать данные с помощью пар ключ-значение. Они являются основным инструментом для управления структурированными данными, ускоряя доступ к конкретным элементам без необходимости итерации по списку.

## Как использовать:

В Clojure создание и управление ассоциативными массивами (хеш-таблицами) происходит просто и наглядно. Давайте разберёмся на примерах.

Чтобы создать хеш-таблицу:

```clojure
(def my-map {:name "Alex" :age 30})
```

Вы можете извлечь значение, указав его ключ:

```clojure
(get my-map :name)
;; "Alex"
```
Или, более идиоматично, вы можете использовать ключ как функцию:

```clojure
(:name my-map)
;; "Alex"
```

Добавление или обновление записей происходит просто:

```clojure
(def updated-map (assoc my-map :location "New York"))
;; {:name "Alex", :age 30, :location "New York"}

(def incremented-age (update my-map :age inc))
;; {:name "Alex", :age 31}
```

Для удаления ключей используйте `dissoc`:

```clojure
(def removed-age (dissoc my-map :age))
;; {:name "Alex"}
```

Для итерации по карте:

```clojure
(doseq [[k v] my-map] (println k "->" v))
;; :name -> Alex
;; :age -> 30
```

И для условного доступа, `find` возвращает пару ключ-значение, если ключ существует:

```clojure
(find my-map :age)
;; [:age 30]
```

## Подробнее

Ассоциативные массивы в Clojure, также часто называемые хеш-таблицами, невероятно универсальны и эффективны для управления данными на основе пар ключ-значение. Они являются частью богатой библиотеки коллекций Clojure, глубоко укоренившейся в философии языка неизменяемости и функционального программирования. В отличие от массивов или списков, которые требуют временной сложности O(n) для доступа к элементам, хеш-таблицы обеспечивают почти постоянную временную сложность доступа, что делает их высокоэффективными для операций поиска.

Можно утверждать, что векторы в Clojure могут служить аналогичной цели за счет индексированного доступа, но хеш-таблицы выигрывают, когда дело доходит до работы с не последовательными и маркированными данными, где ключ обеспечивает значимый дескриптор, а не произвольный индекс.

Уникально для Clojure (и его наследия Lisp), ассоциативные массивы являются объектами первого класса, что означает, что их можно непосредственно манипулировать, передавать в функции и многое другое, без необходимости специального синтаксиса или методов доступа. Это решение подчеркивает акцент Clojure на простоте и мощности.

Хотя хеш-таблицы невероятно полезны, стоит упомянуть, что для очень больших наборов данных или сценариев, когда ключи чрезвычайно динамичны (постоянное добавление и удаление), альтернативные структуры данных или базы данных могут предложить лучшую производительность и гибкость. Тем не менее, для большинства типичных сценариев использования в приложениях Clojure, ассоциативные массивы предоставляют надежное и эффективное средство управления данными.
