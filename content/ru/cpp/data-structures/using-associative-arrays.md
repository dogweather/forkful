---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:10:40.290041-07:00
description: "\u041A\u0430\u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\
  \u0430\u0442\u044C: \u0412 C++, \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\
  \u0438\u0432\u043D\u044B\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B \u043E\
  \u0436\u0438\u0432\u0430\u044E\u0442 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\
  \u044E \u0437\u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432 `<map>` \u0438\
  \ `<unordered_map>`. \u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u0440\u0430\u0441\
  \u0441\u043C\u043E\u0442\u0440\u0438\u043C \u043F\u0440\u0438\u043C\u0435\u0440\u044B\
  , \u0447\u0442\u043E\u0431\u044B \u0443\u0432\u0438\u0434\u0435\u0442\u044C \u0438\
  \u0445 \u0432\u2026"
lastmod: '2024-03-13T22:44:45.595184-06:00'
model: gpt-4-0125-preview
summary: "\u0412 C++, \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\
  \u043D\u044B\u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B \u043E\u0436\u0438\
  \u0432\u0430\u044E\u0442 \u0441 \u043F\u043E\u043C\u043E\u0449\u044C\u044E \u0437\
  \u0430\u0433\u043E\u043B\u043E\u0432\u043A\u043E\u0432 `<map>` \u0438 `<unordered_map>`."
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
weight: 15
---

## Как использовать:
В C++, ассоциативные массивы оживают с помощью заголовков `<map>` и `<unordered_map>`. Давайте рассмотрим примеры, чтобы увидеть их в действии.

### Использование `std::map`
`std::map` хранит элементы, отсортированные на основе ключа. Вот как начать:

```C++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> ageMap;
    
    // Вставка значений
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    
    // Доступ к значениям
    std::cout << "Возраст Боба: " << ageMap["Bob"] << std::endl;
    
    // Перебор map
    for(const auto &pair : ageMap) {
        std::cout << pair.first << " имеет возраст " << pair.second << " лет." << std::endl;
    }
    
    return 0;
}
```

### Использование `std::unordered_map`
Когда порядок не имеет значения, но важна производительность, `std::unordered_map` ваш выбор, предлагая более быструю среднюю сложность для вставок, поиска и удалений.

```C++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, double> productPrice;
    
    // Вставка значений
    productPrice["milk"] = 2.99;
    productPrice["bread"] = 1.99;
    
    // Доступ к значениям
    std::cout << "Цена молока: $" << productPrice["milk"] << std::endl;
    
    // Перебор unordered_map
    for(const auto &pair : productPrice) {
        std::cout << pair.first << " стоит $" << pair.second << std::endl;
    }
    
    return 0;
}
```

## Глубокое погружение
Ассоциативные массивы в C++, особенно `std::map` и `std::unordered_map`, не просто о хранении элементов. Они обеспечивают основу для более сложного управления данными, позволяя осуществлять операции поиска, вставки и удаления за эффективное время (логарифмическая сложность для `std::map` и константа в среднем случае для `std::unordered_map`). Эффективность обусловлена используемыми внутренними структурами данных: сбалансированным деревом для `std::map` и хеш-таблицей для `std::unordered_map`.

Исторически, до их включения в стандартную библиотеку, программисты должны были реализовывать собственные версии или использовать сторонние библиотеки, что приводило к несоответствиям и потенциальным неэффективностям. Включение карт в стандартную библиотеку C++ не только стандартизировало их использование, но и оптимизировало для повышения производительности на разных компиляторах и платформах.

Хотя оба варианта мощные, выбор между `std::map` и `std::unordered_map` зависит от конкретики вашего случая. Нужны упорядоченные данные и небольшая потеря производительности не критична? Используйте `std::map`. Если вам важна скорость и порядок не важен, `std::unordered_map` вероятно будет лучшим выбором.

Однако важно отметить, что при работе со сложными структурами данных всегда есть компромиссы. В некоторых узкоспециализированных случаях другие структуры данных или даже сторонние библиотеки могут предложить лучшую производительность или функциональность, подходящую для ваших конкретных потребностей. Всегда взвешивайте свои варианты на основе требований вашего проекта.
