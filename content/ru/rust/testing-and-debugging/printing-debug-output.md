---
title:                "Вывод отладочной информации"
aliases: - /ru/rust/printing-debug-output.md
date:                  2024-01-29T00:01:17.167288-07:00
model:                 gpt-4-0125-preview
simple_title:         "Вывод отладочной информации"

tag:                  "Testing and Debugging"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/rust/printing-debug-output.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Почему?
Вывод отладочной информации позволяет вам заглянуть в состояние вашей программы без использования полноценного отладчика. Это быстро, неаккуратно, но идеально подходит для поиска коварных ошибок, когда вам не нужен весь арсенал специализированного инструмента отладки.

## Как это сделать:

Для вывода чего-то простого используйте `println!`. Если вам нужно вывести значение для отладки, `dbg!` окажется очень кстати.

```Rust
fn main() {
    let mut vec = vec![1, 2, 3];
    
    // Базовый вывод
    println!("Привет, растафарианцы!");

    // Форматирование отладочного вывода с помощью println! используя `{:?}`
    println!("{:?}", vec);

    // Отладка с `dbg!`, выводит в stderr и возвращает значение
    dbg!(&vec);

    // Изменяем vec после использования `dbg!`
    vec.push(4);
    dbg!(vec);
}
```

Пример вывода:

```
Привет, растафарианцы!
[1, 2, 3]
[src/main.rs:9] &vec = [
    1,
    2,
    3,
]
[src/main.rs:13] vec = [
    1,
    2,
    3,
    4,
]
```

## Глубокое погружение

Вывод отладочной информации был простой и прямолинейной частью программирования с самых ранних дней. Его простота часто делает его предпочитаемым выбором для быстрой диагностики проблем.

В Rust, `println!` отлично подходит для отображения сообщений, понятных пользователю. Магия начинается с `dbg!`, введенного в Rust 1.32, который выводит как значение, так и его местоположение в коде. Вывод происходит в стандартный поток ошибок (stderr), поэтому он не смешивается со стандартным выводом (stdout) и может быть перенаправлен отдельно, если это необходимо.

Для сложных типов вы можете вывести трейт `Debug`, чтобы автоматически создать формат, который `println!` и `dbg!` могут использовать. Вот что делает аннотация `#[derive(Debug)]` над вашими структурами и перечислениями.

Что касается альтернатив, существуют специализированные системы логирования, такие как `log` и `env_logger`, и если вам нужен более детализированный контроль, рассмотрите возможность использования отладчика, такого как `gdb` или `lldb`, которые работают с Rust через интеграции вроде `rust-gdb` или `rust-lldb`.

## Смотрите также

Для дополнительной информации о выводе отладочной информации и форматировании в Rust:

- Книга по Rust о `println!` и Форматировании: https://doc.rust-lang.org/std/fmt/index.html
- Документация макроса `dbg!`: https://doc.rust-lang.org/std/macro.dbg.html
- Официальное руководство по отладке с `gdb` и `lldb`: https://rust-lang.github.io/rustup-components-history
- Крейт `log` для более структурированного подхода к логированию: https://crates.io/crates/log
- Крейт `env_logger`, распространенная реализация логгера для фасада `log`: https://crates.io/crates/env_logger
