---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:01:57.256677-07:00
description: "\u0423\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u043A\u0430\u0432\u044B\
  \u0447\u0435\u043A \u0438\u0437 \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 Rust\
  \ \u0437\u0430\u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u0438\
  \u0437\u0431\u0430\u0432\u043B\u0435\u043D\u0438\u0438 \u043E\u0442 \u043B\u0438\
  \u0448\u043D\u0438\u0445 \u043A\u0430\u0432\u044B\u0447\u0435\u043A, \u043A\u043E\
  \u0442\u043E\u0440\u044B\u0435 \u043C\u043E\u0433\u0443\u0442 \u0431\u044B\u0442\
  \u044C \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u044B \u043A \u0432\u0430\
  \u0448\u0438\u043C \u0442\u0435\u043A\u0441\u0442\u043E\u0432\u044B\u043C \u0434\
  \u0430\u043D\u043D\u044B\u043C. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\
  \u0438\u0441\u0442\u044B \u0434\u0435\u043B\u0430\u044E\u0442\u2026"
lastmod: '2024-03-13T22:44:44.643901-06:00'
model: gpt-4-0125-preview
summary: "\u0423\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u043A\u0430\u0432\u044B\
  \u0447\u0435\u043A \u0438\u0437 \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 Rust\
  \ \u0437\u0430\u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u0438\
  \u0437\u0431\u0430\u0432\u043B\u0435\u043D\u0438\u0438 \u043E\u0442 \u043B\u0438\
  \u0448\u043D\u0438\u0445 \u043A\u0430\u0432\u044B\u0447\u0435\u043A, \u043A\u043E\
  \u0442\u043E\u0440\u044B\u0435 \u043C\u043E\u0433\u0443\u0442 \u0431\u044B\u0442\
  \u044C \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u044B \u043A \u0432\u0430\
  \u0448\u0438\u043C \u0442\u0435\u043A\u0441\u0442\u043E\u0432\u044B\u043C \u0434\
  \u0430\u043D\u043D\u044B\u043C. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\
  \u0438\u0441\u0442\u044B \u0434\u0435\u043B\u0430\u044E\u0442\u2026"
title: "\u0423\u0434\u0430\u043B\u0435\u043D\u0438\u0435 \u043A\u0430\u0432\u044B\u0447\
  \u0435\u043A \u0438\u0437 \u0441\u0442\u0440\u043E\u043A\u0438"
---

{{< edit_this_page >}}

## Что и почему?

Удаление кавычек из строки в Rust заключается в избавлении от лишних кавычек, которые могут быть добавлены к вашим текстовым данным. Программисты делают это, когда им необходимо очистить или нормализовать строки, возможно, после анализа данных из файла или когда они готовят их к другому формату, где кавычки могут быть проблематичными или избыточными.

## Как это сделать:

```Rust
fn remove_quotes(s: &str) -> String {
    s.trim_matches(|c| c == '\"' || c == '\'').to_string()
}

fn main() {
    let quoted_str = "\"Привет, Растафарии!\"";
    let cleaned_str = remove_quotes(quoted_str);
    println!("{}", cleaned_str);
    // Вывод: Привет, Растафарии!
}
```

Иногда у вас может быть строка с разными видами кавычек, вот так:

```Rust
fn main() {
    let mixed_quoted = "'Раст говорит: \"Привет, мир!\"'";
    let cleaned_str = remove_quotes(mixed_quoted);
    println!("{}", cleaned_str);
    // Вывод: Раст говорит: "Привет, мир!"
}
```

Здесь удаляются только наружные одинарные кавычки.

## Глубокое погружение

Когда вы удаляете кавычки из строки, вы можете задаться вопросом, почему нельзя просто использовать `.replace("\"", "")`. Раньше обработка текста была менее стандартизированной, и разные системы имели разные способы хранения и передачи текста, часто с некими 'escape последовательностями' для специальных символов. Метод `trim_matches` более универсален, позволяя указывать несколько символов для обрезки, и возможность обрезать с начала (префикс), с конца (суффикс) или с обеих сторон строки.

Конечно, есть альтернативы. Regex является мощным инструментом для манипуляции строками, способным соответствовать сложным паттернам, и будет избыточным только для удаления кавычек. Библиотеки вроде `trim_in_place` могли бы предложить обрезку на месте без накладных расходов на создание нового объекта `String`, что может быть желательно для приложений, где критична производительность.

Под капотом `trim_matches` на самом деле итерирует через символы строки с обоих концов, проверяя их на соответствие предоставленному шаблону до тех пор, пока не найдет символ, который не соответствует. Это эффективно для его задач, но всегда помните, что он работает с скалярными значениями Unicode. Если ваша строка может содержать многобайтовые символы Unicode, вам не о чем беспокоиться, он не разобьет их.

## Смотрите также

- Документация Rust по манипуляции со строками: https://doc.rust-lang.org/book/ch08-02-strings.html
- Крейт `regex` для сложных паттернов: https://crates.io/crates/regex
- Rust на примере для практических сценариев кодирования: https://doc.rust-lang.org/stable/rust-by-example/std/str.html
