---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:11:45.053394-07:00
description: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u0437\u0432\u0435\u0441\
  \u0442\u043D\u044B\u0435 \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u044F\u0437\
  \u044B\u043A\u0430\u0445 \u043A\u0430\u043A \u043A\u0430\u0440\u0442\u044B \u0438\
  \u043B\u0438 \u0441\u043B\u043E\u0432\u0430\u0440\u0438, \u044F\u0432\u043B\u044F\
  \u044E\u0442\u0441\u044F \u043F\u0430\u0440\u0430\u043C\u0438 \u043A\u043B\u044E\
  \u0447-\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435, \u0438\u0441\u043F\u043E\
  \u043B\u044C\u0437\u0443\u0435\u043C\u044B\u043C\u0438 \u0434\u043B\u044F \u044D\
  \u0444\u0444\u0435\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u043F\u043E\u0438\
  \u0441\u043A\u0430 \u0438 \u043C\u0430\u043D\u0438\u043F\u0443\u043B\u044F\u0446\
  \u0438\u0438\u2026"
lastmod: '2024-03-13T22:44:45.903640-06:00'
model: gpt-4-0125-preview
summary: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u0437\u0432\u0435\u0441\
  \u0442\u043D\u044B\u0435 \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u044F\u0437\
  \u044B\u043A\u0430\u0445 \u043A\u0430\u043A \u043A\u0430\u0440\u0442\u044B \u0438\
  \u043B\u0438 \u0441\u043B\u043E\u0432\u0430\u0440\u0438, \u044F\u0432\u043B\u044F\
  \u044E\u0442\u0441\u044F \u043F\u0430\u0440\u0430\u043C\u0438 \u043A\u043B\u044E\
  \u0447-\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435, \u0438\u0441\u043F\u043E\
  \u043B\u044C\u0437\u0443\u0435\u043C\u044B\u043C\u0438 \u0434\u043B\u044F \u044D\
  \u0444\u0444\u0435\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u043F\u043E\u0438\
  \u0441\u043A\u0430 \u0438 \u043C\u0430\u043D\u0438\u043F\u0443\u043B\u044F\u0446\
  \u0438\u0438\u2026"
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
weight: 15
---

## Что и почему?

Ассоциативные массивы, известные в других языках как карты или словари, являются парами ключ-значение, используемыми для эффективного поиска и манипуляции данными. В отличие от традиционных массивов, использующих индексы-целые числа, ассоциативные массивы используют ключи, что делает доступ к данным более интуитивно понятным и гибким для программистов.

## Как это сделать:

C не имеет встроенной поддержки ассоциативных массивов, как некоторые языки высокого уровня, но вы можете симулировать их, используя структуры и хеширование. Ниже приводится простой пример с использованием комбинации структуры и простой хеш-функции для реализации ассоциативного массива для хранения и доступа к целым числам по строковым ключам.

Сначала определите структуру для представления одной пары ключ-значение и другую для представления самого ассоциативного массива:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 128

typedef struct {
    char* key;
    int value;
} KeyValuePair;

typedef struct {
    KeyValuePair* items[TABLE_SIZE];
} AssocArray;

unsigned int hash(char* key) {
    unsigned long int value = 0;
    unsigned int i = 0;
    unsigned int key_len = strlen(key);

    for (; i < key_len; ++i) {
        value = value * 37 + key[i];
    }

    value = value % TABLE_SIZE;

    return value;
}

void initArray(AssocArray* array) {
    for (int i = 0; i < TABLE_SIZE; ++i) {
        array->items[i] = NULL;
    }
}

void insert(AssocArray* array, char* key, int value) {
    unsigned int slot = hash(key);

    KeyValuePair* item = (KeyValuePair*)malloc(sizeof(KeyValuePair));
    item->key = strdup(key);
    item->value = value;

    array->items[slot] = item;
}

int find(AssocArray* array, char* key) {
    unsigned int slot = hash(key);

    if (array->items[slot]) {
        return array->items[slot]->value;
    }
    return -1;
}

int main() {
    AssocArray a;
    initArray(&a);

    insert(&a, "key1", 1);
    insert(&a, "key2", 2);

    printf("%d\n", find(&a, "key1")); // Выведет: 1
    printf("%d\n", find(&a, "key2")); // Выведет: 2

    return 0;
}
```

Этот пример демонстрирует основные операции: инициализация ассоциативного массива, вставка пар ключ-значение и поиск значений по ключам. Обратите внимание, что этот код не обрабатывает коллизии и предназначен для образовательных целей.

## Глубокое погружение

Концепция ассоциативных массивов предшествует языку C, но низкоуровневая природа языка не поддерживает их напрямую как встроенные типы. Это способствует более глубокому пониманию структур данных и алгоритмов, включая механизмы хеширования для эффективного сопоставления ключ-значение. Многие библиотеки и фреймворки C предлагают более сложные подходы к реализации ассоциативных массивов, такие как `GHashTable` от GLib, которая предоставляет устойчивую реализацию с обработкой коллизий, динамическим изменением размера и поддержкой произвольных типов ключей и значений.

Хотя ручное создание ассоциативных массивов в C может казаться более обременительным по сравнению с языками, имеющими встроенную поддержку, это предоставляет ценные взгляды на внутреннее устройство структур данных, улучшая навыки программиста в решении проблем и оптимизации. Однако для продуктового кода или более сложных приложений использование существующих библиотек, таких как GLib, часто является более практичным и экономящим время подходом.
