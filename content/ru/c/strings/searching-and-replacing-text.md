---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:08:45.852979-07:00
description: "\u041F\u043E\u0438\u0441\u043A \u0438 \u0437\u0430\u043C\u0435\u043D\
  \u0430 \u0442\u0435\u043A\u0441\u0442\u0430 \u0432 C \u0437\u0430\u043A\u043B\u044E\
  \u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u043E\u043F\u0440\u0435\u0434\u0435\
  \u043B\u0435\u043D\u0438\u0438 \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\
  \u043D\u044B\u0445 \u043F\u043E\u0434\u0441\u0442\u0440\u043E\u043A \u0432\u043D\
  \u0443\u0442\u0440\u0438 \u0431\u043E\u043B\u044C\u0448\u0435\u0439 \u0441\u0442\
  \u0440\u043E\u043A\u0438 \u0438 \u0438\u0445 \u0437\u0430\u043C\u0435\u043D\u0435\
  \ \u043D\u0430 \u0434\u0440\u0443\u0433\u0438\u0435 \u043F\u043E\u0434\u0441\u0442\
  \u0440\u043E\u043A\u0438. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0438\
  \u0441\u0442\u044B \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u044E\u0442\u2026"
lastmod: '2024-03-13T22:44:45.889078-06:00'
model: gpt-4-0125-preview
summary: "\u041F\u043E\u0438\u0441\u043A \u0438 \u0437\u0430\u043C\u0435\u043D\u0430\
  \ \u0442\u0435\u043A\u0441\u0442\u0430 \u0432 C \u0437\u0430\u043A\u043B\u044E\u0447\
  \u0430\u0435\u0442\u0441\u044F \u0432 \u043E\u043F\u0440\u0435\u0434\u0435\u043B\
  \u0435\u043D\u0438\u0438 \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u043D\
  \u044B\u0445 \u043F\u043E\u0434\u0441\u0442\u0440\u043E\u043A \u0432\u043D\u0443\
  \u0442\u0440\u0438 \u0431\u043E\u043B\u044C\u0448\u0435\u0439 \u0441\u0442\u0440\
  \u043E\u043A\u0438 \u0438 \u0438\u0445 \u0437\u0430\u043C\u0435\u043D\u0435 \u043D\
  \u0430 \u0434\u0440\u0443\u0433\u0438\u0435 \u043F\u043E\u0434\u0441\u0442\u0440\
  \u043E\u043A\u0438."
title: "\u041F\u043E\u0438\u0441\u043A \u0438 \u0437\u0430\u043C\u0435\u043D\u0430\
  \ \u0442\u0435\u043A\u0441\u0442\u0430"
weight: 10
---

## Что и Почему?

Поиск и замена текста в C заключается в определении определенных подстрок внутри большей строки и их замене на другие подстроки. Программисты выполняют эти операции для манипуляции текстовыми данными - для задач, варьирующихся от санитизации данных и форматирования до динамической генерации содержимого.

## Как:

C не имеет встроенных функций для непосредственного выполнения поиска и замены в строках. Однако, это можно достичь, комбинируя различные функции обработки строк, доступные в библиотеке `<string.h>`, вместе с некоторой пользовательской логикой. Ниже приведен базовый пример того, как искать подстроку в строке и заменять ее. Для простоты этот пример предполагает достаточный размер буфера и не обрабатывает проблемы распределения памяти, которые следует учитывать в производственном коде.

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void replaceSubstring(char *source, char *sub, char *new_sub) {
    char buffer[1024];
    char *insert_point = &buffer[0];
    const char *tmp = source;
    size_t len_sub = strlen(sub), len_new_sub = strlen(new_sub);
    size_t len_up_to_match;

    while ((tmp = strstr(tmp, sub))) {
        // Рассчитать длину до совпадения
        len_up_to_match = tmp - source;
        
        // Копировать часть перед совпадением
        memcpy(insert_point, source, len_up_to_match);
        insert_point += len_up_to_match;
        
        // Копировать новую подстроку
        memcpy(insert_point, new_sub, len_new_sub);
        insert_point += len_new_sub;
        
        // Переместиться за совпадение в исходной строке
        tmp += len_sub;
        source = tmp;
    }
    
    // Копировать оставшуюся часть исходной строки
    strcpy(insert_point, source);
    
    // Вывести измененную строку
    printf("Измененная строка: %s\n", buffer);
}

int main() {
    char sourceStr[] = "Hello, this is a test. This test is simple.";
    char sub[] = "test";
    char newSub[] = "sample";
    
    replaceSubstring(sourceStr, sub, newSub);
    
    return 0;
}
```

Пример вывода:
```
Измененная строка: Hello, this is a sample. This sample is simple.
```

Этот код демонстрирует простой способ поиска всех экземпляров подстроки (`sub`) в исходной строке и их замены на другую подстроку (`newSub`), используя функцию `strstr` для нахождения начальной точки каждого совпадения. Это очень простой пример, который не учитывает сложные сценарии, такие как перекрывающиеся подстроки.

## Углубляемся

Подход, использованный в разделе "Как", является фундаментальным, иллюстрирующим, как добиться поиска и замены текста в C без каких-либо сторонних библиотек. Исторически, из-за акцента C на низкоуровневом управлении памятью и производительности, его стандартная библиотека не инкапсулирует функциональности манипуляции с строками высокого уровня, как те, что можно найти в языках, таких как Python или JavaScript. Программистам приходится вручную управлять памятью и комбинировать различные операции со строками, чтобы достичь желаемых результатов, что увеличивает сложность, но предоставляет больше контроля и эффективности.

Важно отметить, что этот ручной подход может быть подвержен ошибкам, особенно при управлении распределением памяти и размерами буферов. Неправильное обращение может привести к переполнению буфера и повреждению памяти, делая код уязвимым для безопасностных рисков.

Во многих практических сценариях, особенно тех, что требуют сложной обработки текста, часто стоит рассмотреть интеграцию сторонних библиотек, таких как PCRE (Perl Compatible Regular Expressions) для поиска и замены на основе регулярных выражений, что может упростить код и снизить потенциал ошибок. Кроме того, современные стандарты и компиляторы C все чаще предлагают встроенные функции и безопасные альтернативы для манипуляции строками, стремясь смягчить общие проблемы, наблюдаемые в старых кодовых базах C. Тем не менее, фундаментальное понимание ручной обработки текста остается ценным навыком в арсенале программиста, особенно для оптимизации приложений, критичных к производительности.
