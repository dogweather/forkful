---
title:                "Чтение текстового файла"
aliases:
- /ru/haskell/reading-a-text-file.md
date:                  2024-01-29T00:01:19.828264-07:00
model:                 gpt-4-0125-preview
simple_title:         "Чтение текстового файла"

tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/haskell/reading-a-text-file.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Почему?
Чтение текстового файла в программировании позволяет вашему коду получать данные, как если бы вы заливали кофе себе в мозг утром. Мы делаем это для того, чтобы подать программам информацию, которой они иначе бы не имели, как настройки, данные для обработки или инструкции для выполнения.

## Как это сделать:
Вот как заставить Haskell читать текстовые файлы, не потея. Откройте ваш любимый редактор, и давайте писать код.

```Haskell
import System.IO

main = do
    -- Открываем файл в режиме чтения
    handle <- openFile "hello.txt" ReadMode
    -- Читаем содержимое файла
    content <- hGetContents handle
    -- Печатаем содержимое файла
    putStrLn content
    -- Не забываем закрыть дескриптор файла!
    hClose handle
```

Запустите это, и если у вас есть "hello.txt" с "Hello, World!" внутри, вы получите:

```
Hello, World!
```

Вот более короткий и изящный способ, делающий то же самое, но без лишних хлопот:

```Haskell
-- 'readFile' открывает и читает одним махом
main = do
    content <- readFile "hello.txt"
    putStrLn content
```

Выходные данные все те же,

```
Hello, World!
```

## Погружение

Давным-давно программы были асоциальными существами, в основном обрабатывающими данные, которые они сами же и генерировали. Но со временем сложность возросла, как и необходимость привлекать внешнюю информацию, так что чтение из файлов стало обыденным делом.

Haskell предлагает различные способы чтения файлов. Мы можем делать это низкоуровневым способом с помощью `openFile`, `hGetContents` и `hClose` или действовать проще с `readFile`, который аккуратно все упаковывает.

`readFile` - ленивый; он читает содержимое по мере необходимости, что эффективно по памяти для больших файлов, но может привести к сюрпризам, если файл изменяется посреди работы. Низкоуровневый подход дает больше контроля, делая его более предсказуемым, но также и более многословным. Для гигантских текстов помогают управлять памятью и обработкой более тонко такие функции Haskell, как `hGetLine`, или библиотеки вроде `conduit` и `pipes`.

Стандартные `IO` действия Haskell обращаются с файлами, используя механизмы базовой ОС. Библиотеки абстрагируют это в более удобные для пользователя операции, но в конечном счете они построены на основе `IO` монады Haskell, что обеспечивает выполнение действий в правильном порядке.

## Смотрите также

- Для официальной документации Haskell, посетите [документацию Haskell по вводу и выводу](https://www.haskell.org/tutorial/io.html).
- Если хотите узнать больше, насладитесь чашечкой знаний на [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/input-and-output).
- Углубите свое понимание управления файлами с [точки зрения IO в Real World Haskell](http://book.realworldhaskell.org/read/io.html).
- Исследуйте библиотеки потоковой передачи для больших файлов с [conduit](https://hackage.haskell.org/package/conduit) и [pipes](https://hackage.haskell.org/package/pipes).
