---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:02:14.612534-07:00
description: "\u041A\u0430\u043A: Haskell \u0438\u0441\u043F\u043E\u043B\u044C\u0437\
  \u0443\u0435\u0442 \u0444\u0443\u043D\u043A\u0446\u0438\u0438 `round`, `ceiling`,\
  \ `floor` \u0438 `truncate` \u0438\u0437 `Prelude` \u0434\u043B\u044F \u043E\u043F\
  \u0435\u0440\u0430\u0446\u0438\u0439 \u043E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\
  \u0438\u044F."
lastmod: '2024-03-13T22:44:45.124461-06:00'
model: gpt-4-0125-preview
summary: "Haskell \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442 \u0444\
  \u0443\u043D\u043A\u0446\u0438\u0438 `round`, `ceiling`, `floor` \u0438 `truncate`\
  \ \u0438\u0437 `Prelude` \u0434\u043B\u044F \u043E\u043F\u0435\u0440\u0430\u0446\
  \u0438\u0439 \u043E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u044F."
title: "\u041E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u0435 \u0447\u0438\u0441\
  \u0435\u043B"
weight: 13
---

## Как:
Haskell использует функции `round`, `ceiling`, `floor` и `truncate` из `Prelude` для операций округления.

```haskell
import Prelude

main :: IO ()
main = do
  let num = 3.567
  print $ round num    -- 4
  print $ ceiling num  -- 4
  print $ floor num    -- 3
  print $ truncate num -- 3
  
  -- Округление до указанного десятичного знака в Prelude не предусмотрено.
  -- Вот пользовательская функция:
  let roundTo n f = (fromInteger $ round $ f * (10^n)) / (10.0^^n)
  print $ roundTo 1 num -- 3.6
```

## Подробнее
Исторически, округление имеет большое значение в численном анализе и информатике, поскольку оно критически важно для минимизации накопления ошибок в вычислениях, особенно до того, как представления чисел с плавающей точкой были стандартизированы согласно IEEE 754.

Как округлять? `round` направляет к ближайшему целому числу — вверх или вниз. `ceiling` и `floor` всегда округляют вверх или вниз до ближайшего целого числа соответственно, в то время как `truncate` просто отбрасывает десятичные точки.

Альтернативы этим функциям могут включать в себя пользовательскую логику, как наш `roundTo`, или вы можете подключить библиотеки (например, Data.Fixed) для более сложных требований.

Будьте осторожны с неожиданными результатами из-за того, как Haskell обрабатывает случаи, находящиеся ровно посередине при использовании `round` (округляет до ближайшего четного числа).

## Смотрите также
- Документация Haskell Prelude по функциям округления: https://hackage.haskell.org/package/base-4.16.1.0/docs/Prelude.html
- Haskell Wiki по арифметике с плавающей точкой: https://wiki.haskell.org/Floating_point_arithmetic
- Стандарт IEEE 754-2008 для более подробной информации о том, как обрабатываются числа с плавающей точкой во многих языках: https://ieeexplore.ieee.org/document/4610935
