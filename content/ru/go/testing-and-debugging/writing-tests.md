---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:15:50.090406-07:00
description: "\u041A\u0430\u043A: \u0412 Go \u0442\u0435\u0441\u0442\u044B, \u043A\
  \u0430\u043A \u043F\u0440\u0430\u0432\u0438\u043B\u043E, \u043F\u0438\u0448\u0443\
  \u0442\u0441\u044F \u0432 \u0442\u043E\u043C \u0436\u0435 \u043F\u0430\u043A\u0435\
  \u0442\u0435, \u0447\u0442\u043E \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\
  \u0435\u043C\u044B\u0439 \u043A\u043E\u0434. \u0424\u0430\u0439\u043B\u044B, \u0441\
  \u043E\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0435 \u0442\u0435\u0441\u0442\u044B\
  , \u043D\u0430\u0437\u044B\u0432\u0430\u044E\u0442\u0441\u044F \u0441 \u0441\u0443\
  \u0444\u0444\u0438\u043A\u0441\u043E\u043C `_test.go`. \u0422\u0435\u0441\u0442\u044B\
  \ - \u044D\u0442\u043E\u2026"
lastmod: '2024-03-13T22:44:44.116846-06:00'
model: gpt-4-0125-preview
summary: "\u0412 Go \u0442\u0435\u0441\u0442\u044B, \u043A\u0430\u043A \u043F\u0440\
  \u0430\u0432\u0438\u043B\u043E, \u043F\u0438\u0448\u0443\u0442\u0441\u044F \u0432\
  \ \u0442\u043E\u043C \u0436\u0435 \u043F\u0430\u043A\u0435\u0442\u0435, \u0447\u0442\
  \u043E \u0438 \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043C\u044B\u0439\
  \ \u043A\u043E\u0434."
title: "\u041D\u0430\u043F\u0438\u0441\u0430\u043D\u0438\u0435 \u0442\u0435\u0441\u0442\
  \u043E\u0432"
weight: 36
---

## Как:
В Go тесты, как правило, пишутся в том же пакете, что и тестируемый код. Файлы, содержащие тесты, называются с суффиксом `_test.go`. Тесты - это функции, которые принимают указатель на объект testing.T (из пакета `testing`) в качестве аргумента, и они сигнализируют об ошибке, вызывая методы, такие как `t.Fail()`, `t.Errorf()` и т.д.

Пример простого теста для функции `Add`, определенной в `math.go`:
```go
// math.go
package math

func Add(x, y int) int {
    return x + y
}
```

Тестовый файл `math_test.go`:
```go
package math

import "testing"

func TestAdd(t *testing.T) {
    result := Add(1, 2)
    expected := 3
    if result != expected {
        t.Errorf("Add(1, 2) = %d; хотели %d", result, expected)
    }
}
```

Запускайте ваши тесты с помощью команды `go test` в той же директории, что и ваши тестовые файлы. Пример вывода, указывающего на успешное прохождение теста, будет выглядеть следующим образом:

```
PASS
ok      example.com/my/math 0.002s
```

Для табличных тестов, которые позволяют вам эффективно тестировать различные комбинации входных и выходных данных, определите срез структур, представляющих тестовые случаи:

```go
func TestAddTableDriven(t *testing.T) {
    var tests = []struct {
        x        int
        y        int
        expected int
    }{
        {1, 2, 3},
        {2, 3, 5},
        {-1, -2, -3},
    }
    
    for _, tt := range tests {
        testname := fmt.Sprintf("%d+%d", tt.x, tt.y)
        t.Run(testname, func(t *testing.T) {
            ans := Add(tt.x, tt.y)
            if ans != tt.expected {
                t.Errorf("получили %d, хотели %d", ans, tt.expected)
            }
        })
    }
}
```

## Подробнее
Фреймворк для тестирования в Go, представленный в Go 1 наряду с самим языком, был разработан для безшовной интеграции с инструментарием Go, отражая акцент Go на простоту и эффективность в разработке программного обеспечения. В отличие от некоторых фреймворков для тестирования в других языках, которые полагаются на внешние библиотеки или сложные настройки, встроенный пакет `testing` в Go предоставляет простой способ написания и запуска тестов.

Интересной особенностью подхода Go к тестированию является принцип соглашения перед настройкой, который он принимает, например, образец именования файлов (`_test.go`) и использование функциональных возможностей стандартной библиотеки вместо внешних зависимостей. Этот минималистичный подход поощряет разработчиков писать тесты, поскольку порог входа низкий.

Хотя встроенные средства тестирования в Go охватывают многое, существуют сценарии, в которых сторонние инструменты или фреймворки могут предложить больше функциональностей, таких как генерация моков, фаззинг-тестирование или тесты в стиле разработки, ориентированной на поведение (BDD). Популярные библиотеки, такие как Testify или GoMock, дополняют стандартные возможности тестирования в Go, предлагая более выразительные утверждения или возможности генерации моков, которые могут быть особенно полезны в сложных приложениях с множеством зависимостей.

Несмотря на существование этих альтернатив, стандартный пакет тестирования в Go остается краеугольным камнем для тестирования на Go из-за его простоты, производительности и тесной интеграции с языком и инструментарием. Будь то разработчики решают дополнить его сторонними инструментами или нет, фреймворк для тестирования в Go предоставляет надежную основу для обеспечения качества и надежности кода.
