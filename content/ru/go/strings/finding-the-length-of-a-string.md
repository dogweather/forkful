---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:57:05.939478-07:00
description: "\u041E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0435 \u0434\
  \u043B\u0438\u043D\u044B \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 Go \u0437\u0430\
  \u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u0432\u044B\u044F\
  \u0441\u043D\u0435\u043D\u0438\u0438 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\
  \u0432\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432, \u043A\u043E\u0442\
  \u043E\u0440\u044B\u0435 \u043E\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\
  \u0438\u0442. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0438\u0441\u0442\
  \u044B \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E \u0432\u044B\u043F\
  \u043E\u043B\u043D\u044F\u044E\u0442 \u044D\u0442\u0443 \u043E\u043F\u0435\u0440\
  \u0430\u0446\u0438\u044E \u0434\u043B\u044F\u2026"
lastmod: '2024-03-11T00:14:17.617946-06:00'
model: gpt-4-0125-preview
summary: "\u041E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0435 \u0434\
  \u043B\u0438\u043D\u044B \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 Go \u0437\u0430\
  \u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u0432\u044B\u044F\
  \u0441\u043D\u0435\u043D\u0438\u0438 \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\
  \u0432\u0430 \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432, \u043A\u043E\u0442\
  \u043E\u0440\u044B\u0435 \u043E\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\
  \u0438\u0442. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0438\u0441\u0442\
  \u044B \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u043E \u0432\u044B\u043F\
  \u043E\u043B\u043D\u044F\u044E\u0442 \u044D\u0442\u0443 \u043E\u043F\u0435\u0440\
  \u0430\u0446\u0438\u044E \u0434\u043B\u044F\u2026"
title: "\u041E\u043F\u0440\u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0435 \u0434\u043B\
  \u0438\u043D\u044B \u0441\u0442\u0440\u043E\u043A\u0438"
---

{{< edit_this_page >}}

## Что и Почему?
Определение длины строки в Go заключается в выяснении количества символов, которые она содержит. Программисты регулярно выполняют эту операцию для эффективной работы со строками, будь то для валидации, извлечения подстроки или просто для накладывания ограничений на ввод пользователя.

## Как это сделать:
В Go строки рассматриваются как неизменяемые последовательности байтов. Вы можете найти длину строки, используя встроенную функцию `len()`, которая возвращает количество байтов, но не обязательно количество символов. Вот как её использовать:

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// Использование len() для нахождения длины в байтах
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("Длина в байтах:", byteLength) // Вывод: Длина в байтах: 13

	// Для точного получения количества символов или рун в строке
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("Длина в рунах:", runeLength) // Вывод: Длина в рунах: 9
}
```
Первый метод с использованием `len()` может не всегда давать ожидаемый результат, поскольку он считает байты. Для строк, содержащих не-ASCII символы (например, "世界"), вместо этого следует использовать `RuneCountInString` из пакета `unicode/utf8` для точного подсчёта символов Unicode.

## Подробнее
До Go 1 не существовало строгого разграничения для обработки строк как последовательностей байтов в сравнении с последовательностями символов. После Go 1, принятие UTF-8 в качестве стандартной схемы кодирования для строк потребовало более ясных подходов. Функция `len()` отлично работает для строк ASCII, где символы представлены одним байтом. Однако, по мере того как приложения Go стали более глобальными и возникла необходимость поддерживать множество языков и наборов символов, простой подход `len()` показал свои ограничения.

Введение и использование `utf8.RuneCountInString()` ответили на эти ограничения, предоставив способ подсчета фактических символов Unicode (рун в терминологии Go). Этот метод обеспечивает, что расчет длины независим от конкретики кодирования UTF-8, где символы могут занимать несколько байтов.

Альтернативный подход к обходу и манипуляциям со строками, более соответствующий этосу Go о конкурентности и эффективности, может заключаться в обработке строк как срезов рун. Однако, этот метод требует шага преобразования и не решает мгновенно все тонкости Unicode (например, комбинированные символы).

В заключение, хотя `len()` подходит для длины в байтах и эффективен для текста ASCII, `utf8.RuneCountInString()` является более надежным выбором для глобально совместимого приложения. Тем не менее, разработчикам рекомендуется понимать компромиссы в производительности и использовании памяти, которые влекут за собой эти выборы.
