---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:52:22.159529-06:00
description: "\u0E19\u0E34\u0E1E\u0E08\u0E19\u0E4C\u0E1B\u0E01\u0E15\u0E34 (Regular\
  \ expressions), \u0E40\u0E04\u0E23\u0E37\u0E48\u0E2D\u0E07\u0E21\u0E37\u0E2D\u0E17\
  \u0E23\u0E07\u0E1E\u0E25\u0E31\u0E07\u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E01\u0E32\
  \u0E23\u0E08\u0E31\u0E1A\u0E04\u0E39\u0E48\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E41\
  \u0E25\u0E30\u0E01\u0E32\u0E23\u0E08\u0E31\u0E14\u0E01\u0E32\u0E23\u0E02\u0E49\u0E2D\
  \u0E21\u0E39\u0E25, \u0E40\u0E1B\u0E47\u0E19\u0E2A\u0E34\u0E48\u0E07\u0E08\u0E33\
  \u0E40\u0E1B\u0E47\u0E19\u0E43\u0E19\u0E07\u0E32\u0E19\u0E01\u0E32\u0E23\u0E1B\u0E23\
  \u0E30\u0E21\u0E27\u0E25\u0E1C\u0E25\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21 \u0E40\
  \u0E0A\u0E48\u0E19\u2026"
lastmod: '2024-03-17T21:57:55.795597-06:00'
model: gpt-4-0125-preview
summary: "\u0E19\u0E34\u0E1E\u0E08\u0E19\u0E4C\u0E1B\u0E01\u0E15\u0E34 (Regular expressions),\
  \ \u0E40\u0E04\u0E23\u0E37\u0E48\u0E2D\u0E07\u0E21\u0E37\u0E2D\u0E17\u0E23\u0E07\
  \u0E1E\u0E25\u0E31\u0E07\u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E01\u0E32\u0E23\u0E08\
  \u0E31\u0E1A\u0E04\u0E39\u0E48\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E41\u0E25\u0E30\
  \u0E01\u0E32\u0E23\u0E08\u0E31\u0E14\u0E01\u0E32\u0E23\u0E02\u0E49\u0E2D\u0E21\u0E39\
  \u0E25, \u0E40\u0E1B\u0E47\u0E19\u0E2A\u0E34\u0E48\u0E07\u0E08\u0E33\u0E40\u0E1B\
  \u0E47\u0E19\u0E43\u0E19\u0E07\u0E32\u0E19\u0E01\u0E32\u0E23\u0E1B\u0E23\u0E30\u0E21\
  \u0E27\u0E25\u0E1C\u0E25\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21 \u0E40\u0E0A\u0E48\
  \u0E19 \u0E01\u0E32\u0E23\u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E27\u0E32\
  \u0E21\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E2D\u0E07\u0E02\u0E49\u0E2D\
  \u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19, \u0E01\u0E32\u0E23\
  \u0E04\u0E49\u0E19\u0E2B\u0E32 \u0E41\u0E25\u0E30\u0E01\u0E32\u0E23\u0E41\u0E17\u0E19\
  \u0E17\u0E35\u0E48\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21 \u0E42\u0E1B\u0E23\u0E41\
  \u0E01\u0E23\u0E21\u0E40\u0E21\u0E2D\u0E23\u0E4C\u0E43\u0E0A\u0E49\u0E1E\u0E27\u0E01\
  \u0E21\u0E31\u0E19\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E01\u0E27\u0E49\u0E32\u0E07\u0E02\
  \u0E27\u0E32\u0E07\u0E43\u0E19\u0E01\u0E32\u0E23\u0E08\u0E31\u0E14\u0E01\u0E32\u0E23\
  \u0E01\u0E31\u0E1A\u0E07\u0E32\u0E19\u0E01\u0E32\u0E23\u0E41\u0E22\u0E01\u0E2A\u0E32\
  \u0E22\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E25\u0E30\u0E01\u0E32\u0E23\
  \u0E15\u0E23\u0E27\u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E27\u0E32\u0E21\u0E16\u0E39\u0E01\
  \u0E15\u0E49\u0E2D\u0E07\u0E02\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\
  \u0E35\u0E48\u0E0B\u0E31\u0E1A\u0E0B\u0E49\u0E2D\u0E19\u0E44\u0E14\u0E49\u0E2D\u0E22\
  \u0E48\u0E32\u0E07\u0E21\u0E35\u0E1B\u0E23\u0E30\u0E2A\u0E34\u0E17\u0E18\u0E34\u0E20\
  \u0E32\u0E1E\u0E41\u0E25\u0E30\u0E01\u0E23\u0E30\u0E0A\u0E31\u0E1A."
title: "\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E40\u0E23\u0E01\u0E38\u0E25\u0E32\u0E23\
  \u0E4C\u0E40\u0E2D\u0E47\u0E01\u0E40\u0E1E\u0E23\u0E2A\u0E0A\u0E31\u0E19"
weight: 11
---

## อะไร & ทำไม?
นิพจน์ปกติ (Regular expressions), เครื่องมือทรงพลังสำหรับการจับคู่รูปแบบและการจัดการข้อมูล, เป็นสิ่งจำเป็นในงานการประมวลผลข้อความ เช่น การตรวจสอบความถูกต้องของข้อมูลที่ป้อน, การค้นหา และการแทนที่ข้อความ โปรแกรมเมอร์ใช้พวกมันอย่างกว้างขวางในการจัดการกับงานการแยกสายข้อความและการตรวจสอบความถูกต้องของข้อมูลที่ซับซ้อนได้อย่างมีประสิทธิภาพและกระชับ 

## วิธีการ:
Clojure, ยึดมั่นในรากฐานของมันในครอบครัวของ Lisp, มีชุดฟังก์ชันที่หลากหลายซึ่งทำงานร่วมกับความสามารถของ Java ในเรื่อง Regular expression ได้อย่างไม่มีที่ติ นี่คือวิธีที่คุณสามารถใช้มันได้:

### การจับคู่พื้นฐาน
เพื่อตรวจสอบว่าสตริงตรงกับรูปแบบหรือไม่ ใช้ `re-matches` จะคืนค่าการจับคู่ทั้งหมดถ้าสำเร็จหรือ `nil` ถ้าไม่

```clojure
(re-matches #"\d+" "123")  ;=> "123"
(re-matches #"\d+" "abc")  ;=> nil
```

### การค้นหารูปแบบ
เพื่อหาความเกิดขึ้นครั้งแรกของรูปแบบ ให้ใช้ `re-find`:

```clojure
(re-find #"\d+" "Order 123")  ;=> "123"
```

### การจับกลุ่ม
ใช้ `re-find` ควบคู่กับวงเล็บในรูปแบบของคุณเพื่อจับกลุ่ม:

```clojure
(let [[_ area code] (re-find #"(1)?(\d{3})" "Phone: 123-4567")]
  (println "Area Code:" area "Code:" code))
;; Output: Area Code: nil Code: 123
```

### การค้นหาทั่วโลก (ค้นหาการจับคู่ทั้งหมด)
Clojure ไม่มีฟังก์ชันการค้นหาแบบทั่วโลกในตัวเองเหมือนบางภาษา แทนที่ให้ใช้ `re-seq` เพื่อได้รับลำดับของการจับคู่ทั้งหมดเป็นค่าเริ่มต้น:

```clojure
(re-seq #"\d+" "id: 123, qty: 456")  ;=> ("123" "456")
```

### การแบ่งสตริง
เพื่อแบ่งสตริงตามรูปแบบใด ๆ ให้ใช้ `clojure.string/split`:

```clojure
(clojure.string/split "John,Doe,30" #",")  ;=> ["John" "Doe" "30"]
```

### การแทนที่
แทนที่ส่วนของสตริงที่ตรงกับรูปแบบด้วย `clojure.string/replace`:

```clojure
(clojure.string/replace "2023-04-01" #"\d{4}" "YYYY")  ;=> "YYYY-04-01"
```

### ไลบรารีของบุคคลที่สาม
แม้ว่าการสนับสนุนในตัวของ Clojure จะเพียงพอสำหรับกรณีส่วนใหญ่ สำหรับสถานการณ์ที่ซับซ้อนมากขึ้น ให้พิจารณาใช้ไลบรารีเช่น `clojure.spec` สำหรับการตรวจสอบความถูกต้องของข้อมูลอย่างเข้มงวด และ `reagent` สำหรับการจัดการ DOM แบบรีแอคทีฟในเว็บแอปพลิเคชันโดยใช้การกำหนดเส้นทางและการตรวจสอบความถูกต้องของข้อมูลที่ป้อนตามรูปแบบ regex

```clojure
;; ตัวอย่างการใช้ clojure.spec สำหรับการตรวจสอบอีเมล
(require '[clojure.spec.alpha :as s])
(s/def ::email (s/and string? #(re-matches #".+@.+\..+" %)))
(s/valid? ::email "test@example.com")  ;=> true
```

จำไว้ว่า ในขณะที่นิพจน์ปกติมีความสามารถอย่างมาก พวกมันก็สามารถทำให้โค้ดยากต่อการอ่านและดูแลรักษาได้ ใช้พวกมันอย่างรอบคอบและพิจารณาฟังก์ชันการจัดการสตริงที่ง่ายกว่าเมื่อเป็นไปได้
