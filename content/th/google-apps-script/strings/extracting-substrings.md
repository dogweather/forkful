---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:47:02.801706-06:00
description: "\u0E01\u0E32\u0E23\u0E41\u0E22\u0E01\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E22\
  \u0E48\u0E2D\u0E22 (Extracting substrings) \u0E2B\u0E21\u0E32\u0E22\u0E16\u0E36\u0E07\
  \u0E01\u0E32\u0E23\u0E40\u0E2D\u0E32\u0E2A\u0E48\u0E27\u0E19\u0E2B\u0E19\u0E36\u0E48\
  \u0E07\u0E02\u0E2D\u0E07\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E21\u0E32 - \u0E0B\u0E36\
  \u0E48\u0E07\u0E2B\u0E21\u0E32\u0E22\u0E16\u0E36\u0E07\u0E01\u0E32\u0E23\u0E2A\u0E23\
  \u0E49\u0E32\u0E07\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E43\u0E2B\u0E21\u0E48\u0E08\u0E32\
  \u0E01\u0E2A\u0E48\u0E27\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E02\u0E2D\u0E07\u0E2A\
  \u0E15\u0E23\u0E34\u0E07\u0E17\u0E35\u0E48\u0E21\u0E35\u0E2D\u0E22\u0E39\u0E48\u0E40\
  \u0E14\u0E34\u0E21\u2026"
lastmod: '2024-03-17T21:57:55.704804-06:00'
model: gpt-4-0125-preview
summary: "\u0E01\u0E32\u0E23\u0E41\u0E22\u0E01\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E22\
  \u0E48\u0E2D\u0E22 (Extracting substrings) \u0E2B\u0E21\u0E32\u0E22\u0E16\u0E36\u0E07\
  \u0E01\u0E32\u0E23\u0E40\u0E2D\u0E32\u0E2A\u0E48\u0E27\u0E19\u0E2B\u0E19\u0E36\u0E48\
  \u0E07\u0E02\u0E2D\u0E07\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E21\u0E32 - \u0E0B\u0E36\
  \u0E48\u0E07\u0E2B\u0E21\u0E32\u0E22\u0E16\u0E36\u0E07\u0E01\u0E32\u0E23\u0E2A\u0E23\
  \u0E49\u0E32\u0E07\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E43\u0E2B\u0E21\u0E48\u0E08\u0E32\
  \u0E01\u0E2A\u0E48\u0E27\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E02\u0E2D\u0E07\u0E2A\
  \u0E15\u0E23\u0E34\u0E07\u0E17\u0E35\u0E48\u0E21\u0E35\u0E2D\u0E22\u0E39\u0E48\u0E40\
  \u0E14\u0E34\u0E21\u2026"
title: "\u0E01\u0E32\u0E23\u0E14\u0E36\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E22\
  \u0E48\u0E2D\u0E22\u0E2D\u0E2D\u0E01\u0E21\u0E32"
weight: 6
---

## อะไร & ทำไม?

การแยกสตริงย่อย (Extracting substrings) หมายถึงการเอาส่วนหนึ่งของสตริงมา - ซึ่งหมายถึงการสร้างสตริงใหม่จากส่วนหนึ่งของสตริงที่มีอยู่เดิม โปรแกรมเมอร์ทำเช่นนี้ด้วยเหตุผลมากมาย เช่น การแยกข้อมูล (Data parsing), การจัดการข้อความสำหรับอินเตอร์เฟซผู้ใช้ หรือการประมวลผลข้อมูลเข้าสำหรับแอปพลิเคชันต่างๆ ทำให้การแยกสตริงย่อยเป็นเครื่องมือที่หลากหลายในคลังสคริปต์ใดๆ

## วิธีทำ:

ใน Google Apps Script ซึ่งอิงกับ JavaScript สมัยใหม่ การแยกสตริงย่อยสามารถทำได้ผ่านหลายวิธี รวมทั้ง `substring()`, `substr()`, และ `slice()` แต่ละวิธีมีความละเอียดอ่อนเฉพาะตัว แต่ทั้งหมดให้บริการสำหรับการดึงอักขระที่ระบุจากสตริง

```javascript
// ตัวอย่างโดยใช้ substring()
var str = "Hello, world!";
var result = str.substring(0, 5);
console.log(result); // ผลลัพธ์: Hello

// ตัวอย่างโดยใช้ substr()
var resultSubstr = str.substr(7, 5);
console.log(resultSubstr); // ผลลัพธ์: world

// ตัวอย่างโดยใช้ slice()
var resultSlice = str.slice(-6);
console.log(resultSlice); // ผลลัพธ์: world!
```

แต่ละวิธีรับอาร์กิวเมนต์สองตัว: ตำแหน่งเริ่มต้น และตำแหน่งสิ้นสุดหรือจำนวนอักขระที่จะแยก ยกเว้นสำหรับ `slice()` ซึ่งสามารถรับดัชนีลบเพื่อเริ่มต้นจากท้ายสตริงได้ เป็นสิ่งสำคัญที่ต้องทราบว่าสตริงต้นฉบับจะไม่เปลี่ยนแปลงหลังจากการดำเนินการเหล่านี้ เนื่องจากมันจะคืนค่าสตริงใหม่

## ลงลึก

ในประวัติศาสตร์ วิธีการสำหรับการแยกสตริงย่อยใน JavaScript ได้กลายเป็นแหล่งความสับสนเนื่องจากชื่อและฟังก์ชันที่คล้ายคลึงกัน อย่างไรก็ตาม ใน Google Apps Script และ JavaScript สมัยใหม่ `substring()` และ `slice()` ถูกใช้กันอย่างแพร่หลาย โดยที่ `substr()` ถือว่าเป็น deprecated นี่เป็นสิ่งสำคัญที่ต้องทราบสำหรับผู้ที่เขียนโค้ดที่ยั่งยืนในอนาคต

ความแตกต่างหลักระหว่าง `substring()` และ `slice()` คือวิธีการจัดการดัชนีลบ; `substring()` จะรักษาดัชนีลบเป็น 0 ในขณะที่ `slice()` สามารถรับดัชนีลบเพื่อเริ่มการแยกจากท้ายสตริงได้ นี่ทำให้ `slice()` เป็นตัวเลือกที่น่าสนใจสำหรับกรณีที่อาจไม่ทราบความยาวของสตริงหรือเมื่อต้องการแยกจากท้ายสตริง

เมื่อต้องการตัดสินใจว่าจะใช้วิธีไหนในการแยกสตริงย่อย การเลือกมักจะขึ้นอยู่กับความต้องการเฉพาะของการดำเนินการ (เช่น การจัดการดัชนีลบมีประโยชน์หรือไม่) และมาตรฐานการเขียนโค้ดส่วนบุคคลหรือทีม แม้ว่าจะไม่มีทางปฏิบัติที่ดีที่สุดเดียวสำหรับทุกสถานการณ์ การเข้าใจความแตกต่างที่ละเอียดอ่อนและผลกระทบด้านประสิทธิภาพสามารถช่วยในการตัดสินใจที่มีข้อมูลครบถ้วน.
