---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:51:02.606829-06:00
description: "\u0E01\u0E32\u0E23\u0E04\u0E49\u0E19\u0E2B\u0E32\u0E41\u0E25\u0E30\u0E41\
  \u0E17\u0E19\u0E17\u0E35\u0E48\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E43\u0E19\
  \u0E20\u0E32\u0E29\u0E32 C \u0E04\u0E37\u0E2D\u0E01\u0E32\u0E23\u0E23\u0E30\u0E1A\
  \u0E38\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E22\u0E48\u0E2D\u0E22\u0E43\u0E19\u0E2A\u0E15\
  \u0E23\u0E34\u0E07\u0E17\u0E35\u0E48\u0E43\u0E2B\u0E0D\u0E48\u0E01\u0E27\u0E48\u0E32\
  \u0E41\u0E25\u0E30\u0E41\u0E17\u0E19\u0E17\u0E35\u0E48\u0E14\u0E49\u0E27\u0E22\u0E2A\
  \u0E15\u0E23\u0E34\u0E07\u0E22\u0E48\u0E2D\u0E22\u0E2D\u0E37\u0E48\u0E19 \u0E46\u2026"
lastmod: '2024-03-17T21:57:56.671298-06:00'
model: gpt-4-0125-preview
summary: "\u0E01\u0E32\u0E23\u0E04\u0E49\u0E19\u0E2B\u0E32\u0E41\u0E25\u0E30\u0E41\
  \u0E17\u0E19\u0E17\u0E35\u0E48\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E43\u0E19\
  \u0E20\u0E32\u0E29\u0E32 C \u0E04\u0E37\u0E2D\u0E01\u0E32\u0E23\u0E23\u0E30\u0E1A\
  \u0E38\u0E2A\u0E15\u0E23\u0E34\u0E07\u0E22\u0E48\u0E2D\u0E22\u0E43\u0E19\u0E2A\u0E15\
  \u0E23\u0E34\u0E07\u0E17\u0E35\u0E48\u0E43\u0E2B\u0E0D\u0E48\u0E01\u0E27\u0E48\u0E32\
  \u0E41\u0E25\u0E30\u0E41\u0E17\u0E19\u0E17\u0E35\u0E48\u0E14\u0E49\u0E27\u0E22\u0E2A\
  \u0E15\u0E23\u0E34\u0E07\u0E22\u0E48\u0E2D\u0E22\u0E2D\u0E37\u0E48\u0E19 \u0E46\
  \ \u0E42\u0E1B\u0E23\u0E41\u0E01\u0E23\u0E21\u0E40\u0E21\u0E2D\u0E23\u0E4C\u0E17\
  \u0E33\u0E01\u0E32\u0E23\u0E14\u0E33\u0E40\u0E19\u0E34\u0E19\u0E01\u0E32\u0E23\u0E40\
  \u0E2B\u0E25\u0E48\u0E32\u0E19\u0E35\u0E49\u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E08\u0E31\
  \u0E14\u0E01\u0E32\u0E23\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E02\u0E49\u0E2D\u0E04\
  \u0E27\u0E32\u0E21 - \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E07\u0E32\u0E19\u0E15\
  \u0E48\u0E32\u0E07 \u0E46 \u0E15\u0E31\u0E49\u0E07\u0E41\u0E15\u0E48\u0E01\u0E32\
  \u0E23\u0E17\u0E33\u0E04\u0E27\u0E32\u0E21\u0E2A\u0E30\u0E2D\u0E32\u0E14\u0E02\u0E49\
  \u0E2D\u0E21\u0E39\u0E25 \u0E01\u0E32\u0E23\u0E08\u0E31\u0E14\u0E23\u0E39\u0E1B\u0E41\
  \u0E1A\u0E1A \u0E44\u0E1B\u0E08\u0E19\u0E16\u0E36\u0E07\u0E01\u0E32\u0E23\u0E2A\u0E23\
  \u0E49\u0E32\u0E07\u0E40\u0E19\u0E37\u0E49\u0E2D\u0E2B\u0E32\u0E41\u0E1A\u0E1A\u0E44\
  \u0E14\u0E19\u0E32\u0E21\u0E34\u0E01."
title: "\u0E01\u0E32\u0E23\u0E04\u0E49\u0E19\u0E2B\u0E32\u0E41\u0E25\u0E30\u0E41\u0E17\
  \u0E19\u0E17\u0E35\u0E48\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21"
weight: 10
---

## อะไรและทำไม?

การค้นหาและแทนที่ข้อความในภาษา C คือการระบุสตริงย่อยในสตริงที่ใหญ่กว่าและแทนที่ด้วยสตริงย่อยอื่น ๆ โปรแกรมเมอร์ทำการดำเนินการเหล่านี้เพื่อจัดการข้อมูลข้อความ - สำหรับงานต่าง ๆ ตั้งแต่การทำความสะอาดข้อมูล การจัดรูปแบบ ไปจนถึงการสร้างเนื้อหาแบบไดนามิก

## วิธีการ:

ภาษา C ไม่มีฟังก์ชั่นในตัวสำหรับการค้นหาและแทนที่สตริงโดยตรง อย่างไรก็ตาม คุณสามารถทำเช่นนี้ได้โดยการรวมฟังก์ชันการจัดการสตริงต่างๆที่มีอยู่ในไลบรารี `<string.h>` พร้อมกับตรรกะที่กำหนดเอง ด้านล่างเป็นตัวอย่างพื้นฐานของวิธีการค้นหาสตริงย่อยภายในสตริงและแทนที่ สำหรับความง่าย ตัวอย่างนี้สมมุติว่ามีขนาดบัฟเฟอร์เพียงพอและไม่ได้จัดการกับปัญหาการจัดสรรหน่วยความจำซึ่งคุณควรพิจารณาในโค้ดการผลิต

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void replaceSubstring(char *source, char *sub, char *new_sub) {
  char buffer[1024];
  char *insert_point = &buffer[0];
  const char *tmp = source;
  size_t len_sub = strlen(sub), len_new_sub = strlen(new_sub);
  size_t len_up_to_match;

  while ((tmp = strstr(tmp, sub))) {
    // คำนวณความยาวจนถึงจุดที่ตรงกัน
    len_up_to_match = tmp - source;
    
    // คัดลอกส่วนก่อนจุดที่ตรงกัน
    memcpy(insert_point, source, len_up_to_match);
    insert_point += len_up_to_match;
    
    // คัดลอกสตริงย่อยใหม่
    memcpy(insert_point, new_sub, len_new_sub);
    insert_point += len_new_sub;
    
    // เลื่อนผ่านจุดที่ตรงกันในสตริงต้นฉบับ
    tmp += len_sub;
    source = tmp;
  }
  
  // คัดลอกส่วนที่เหลือของสตริงต้นฉบับ
  strcpy(insert_point, source);
  
  // พิมพ์สตริงที่ดัดแปลง
  printf("Modified string: %s\n", buffer);
}

int main() {
  char sourceStr[] = "Hello, this is a test. This test is simple.";
  char sub[] = "test";
  char newSub[] = "sample";
  
  replaceSubstring(sourceStr, sub, newSub);
  
  return 0;
}
```

ตัวอย่างผลลัพธ์:
```
Modified string: Hello, this is a sample. This sample is simple.
```

โค้ดนี้แสดงวิธีการง่ายๆ ในการค้นหาทุกตัวอย่างของสตริงย่อย (`sub`) ในสตริงแหล่งข้อมูลและแทนที่ด้วยสตริงย่อยอื่น (`newSub`) โดยใช้ฟังก์ชัน `strstr` เพื่อหาจุดเริ่มต้นของแต่ละการตรงกัน นี่เป็นตัวอย่างพื้นฐานมากที่ไม่ได้จัดการกับสถานการณ์ที่ซับซ้อนเช่นสตริงย่อยที่ซ้อนทับกัน

## ลงลึก

วิธีการที่ใช้ในส่วน "วิธีการ" นี้เป็นพื้นฐาน เพื่อแสดงการค้นหาและแทนที่ข้อความในภาษา C โดยไม่ต้องใช้ไลบรารีภายนอก อย่างไรก็ตาม ด้วยการเน้นในการจัดการหน่วยความจำแบบระดับต่ำ และประสิทธิภาพ, ไลบรารีมาตรฐานของภาษา C จึงไม่รวมฟังก์ชันการจัดการสตริงระดับสูงเหมือนกับภาษาอื่นๆ เช่น Python หรือ JavaScript โปรแกรมเมอร์ต้องจัดการหน่วยความจำและรวมการดำเนินการสตริงต่างๆเพื่อให้ได้ผลลัพธ์ที่ต้องการ ซึ่งเพิ่มความซับซ้อน แต่ให้อิสระและประสิทธิภาพมากขึ้น

สิ่งสำคัญคือต้องทราบว่าวิธีการนี้อาจเกิดข้อผิดพลาดได้ง่าย โดยเฉพาะอย่างยิ่งเมื่อจัดการกับการจัดสรรหน่วยความจำและขนาดบัฟเฟอร์ การจัดการไม่ถูกต้องอาจนำไปสู่การล้นของบัฟเฟอร์และคอร์รัปชันของหน่วยความจำ ทำให้โค้ดเสี่ยงต่อความเสี่ยงด้านความปลอดภัย

ในหลาย ๆ สถานการณ์ที่ปฏิบัติจริง โดยเฉพาะอย่างยิ่งที่ต้องการการประมวลผลข้อความที่ซับซ้อน ควรพิจารณาการรวมไลบรารีของบุคคลที่สาม เช่น PCRE (Perl Compatible Regular Expressions) สำหรับการค้นหาและแทนที่ด้วย regex ซึ่งสามารถทำให้โค้ดง่ายขึ้นและลดโอกาสผิดพลาด นอกจากนี้ มาตรฐานและคอมไพเลอร์ของภาษา C ในยุคใหม่ก็เสนอฟังก์ชันในตัวและทางเลือกที่ปลอดภัยกว่าสำหรับการจัดการสตริงเพื่อลดปัญหาทั่วไปที่สังเกตได้ในฐานโค้ดภาษา C ยุคเก่า อย่างไรก็ตาม การเข้าใจพื้นฐานของการประมวลผลข้อความแบบด้วยตนเองยังคงเป็นทักษะที่มีค่าสำหรับโปรแกรมเมอร์ โดยเฉพาะเมื่อต้องการเพิ่มประสิทธิภาพในแอปพลิเคชันที่สำคัญต่อประสิทธิภาพ
