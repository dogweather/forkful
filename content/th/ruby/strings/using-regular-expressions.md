---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:52:32.652725-06:00
description: "\u0E19\u0E34\u0E1E\u0E08\u0E19\u0E4C\u0E1B\u0E01\u0E15\u0E34 (regular\
  \ expressions \u0E2B\u0E23\u0E37\u0E2D regex) \u0E43\u0E19 Ruby \u0E40\u0E1B\u0E47\
  \u0E19\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E43\u0E0A\u0E49\u0E08\
  \u0E31\u0E1A\u0E04\u0E39\u0E48\u0E01\u0E32\u0E23\u0E23\u0E27\u0E21\u0E15\u0E31\u0E27\
  \u0E2D\u0E31\u0E01\u0E29\u0E23\u0E43\u0E19\u0E2A\u0E15\u0E23\u0E34\u0E07 \u0E0A\u0E48\
  \u0E27\u0E22\u0E43\u0E2B\u0E49\u0E19\u0E31\u0E01\u0E1E\u0E31\u0E12\u0E19\u0E32\u0E2A\
  \u0E32\u0E21\u0E32\u0E23\u0E16\u0E04\u0E49\u0E19\u0E2B\u0E32, \u0E08\u0E31\u0E1A\
  \u0E04\u0E39\u0E48\u2026"
lastmod: '2024-03-17T21:57:56.717681-06:00'
model: gpt-4-0125-preview
summary: "\u0E19\u0E34\u0E1E\u0E08\u0E19\u0E4C\u0E1B\u0E01\u0E15\u0E34 (regular expressions\
  \ \u0E2B\u0E23\u0E37\u0E2D regex) \u0E43\u0E19 Ruby \u0E40\u0E1B\u0E47\u0E19\u0E23\
  \u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E43\u0E0A\u0E49\u0E08\u0E31\u0E1A\
  \u0E04\u0E39\u0E48\u0E01\u0E32\u0E23\u0E23\u0E27\u0E21\u0E15\u0E31\u0E27\u0E2D\u0E31\
  \u0E01\u0E29\u0E23\u0E43\u0E19\u0E2A\u0E15\u0E23\u0E34\u0E07 \u0E0A\u0E48\u0E27\u0E22\
  \u0E43\u0E2B\u0E49\u0E19\u0E31\u0E01\u0E1E\u0E31\u0E12\u0E19\u0E32\u0E2A\u0E32\u0E21\
  \u0E32\u0E23\u0E16\u0E04\u0E49\u0E19\u0E2B\u0E32, \u0E08\u0E31\u0E1A\u0E04\u0E39\
  \u0E48\u2026"
title: "\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E40\u0E23\u0E01\u0E38\u0E25\u0E32\u0E23\
  \u0E4C\u0E40\u0E2D\u0E47\u0E01\u0E40\u0E1E\u0E23\u0E2A\u0E0A\u0E31\u0E19"
---

{{< edit_this_page >}}

## อะไร & ทำไม?
นิพจน์ปกติ (regular expressions หรือ regex) ใน Ruby เป็นรูปแบบที่ใช้จับคู่การรวมตัวอักษรในสตริง ช่วยให้นักพัฒนาสามารถค้นหา, จับคู่ และดัดแปลงข้อความได้อย่างมีประสิทธิภาพ โปรแกรมเมอร์ใช้ regex สำหรับงานเช่นการตรวจสอบความถูกต้อง, การแยกข้อมูล, และการจัดการสตริง ทำให้เป็นเครื่องมือที่ขาดไม่ได้สำหรับการประมวลผลข้อความ

## วิธีการ:
### การจับคู่พื้นฐาน
เพื่อจับคู่สตริงกับรูปแบบง่าย ๆ คุณสามารถใช้เมธอด `match` ด้านล่าง เรากำลังตรวจสอบว่าคำว่า "Ruby" มีอยู่ในสตริงที่กำหนดหรือไม่

```ruby
if /Ruby/.match("Hello, Ruby!")
  puts "พบการจับคู่!"
end
# ผลลัพธ์: พบการจับคู่!
```

### การจับคู่รูปแบบด้วยตัวแปร
คุณสามารถฝังตัวแปรเข้าไปใน regex ของคุณโดยใช้ไวยากรณ์ `#{}` ทำให้รูปแบบของคุณเป็นแบบไดนามิก

```ruby
language = "Ruby"
if /#{language}/.match("การเขียนโปรแกรมด้วย Ruby สนุก.")
  puts "พูดถึง Ruby!"
end
# ผลลัพธ์: พูดถึง Ruby!
```

### การใช้ Regex สำหรับการแทนที่
เมธอด `gsub` ช่วยให้คุณเปลี่ยนทุกครั้งที่ปรากฏรูปแบบด้วยสตริงที่ระบุเพื่อแทนที่

```ruby
puts "foobarfoo".gsub(/foo/, "bar")
# ผลลัพธ์: barbarbar
```

### การจับกลุ่ม
วงเล็บใน regex ใช้สำหรับการจับกลุ่มส่วนหนึ่งของการจับคู่ เมธอด `match` จะคืนค่าวัตถุ `MatchData` ซึ่งคุณสามารถใช้เพื่อเข้าถึงการจับกลุ่ม

```ruby
match_data = /(\w+): (\d+)/.match("อายุ: 30")
puts match_data[1] # ป้ายกำกับที่จับกลุ่ม
puts match_data[2] # ค่าที่จับกลุ่ม
# ผลลัพธ์:
# อายุ
# 30
```

### การใช้ไลบรารีของบุคคลที่สาม
แม้ว่าไลบรารีมาตรฐานของ Ruby จะมีพลังมาก คุณอาจต้องการความสามารถพิเศษบางอย่างบ้างเป็นบางครั้ง หนึ่งใน gem ยอดนิยมสำหรับการทำงานกับ regex คือ `Oniguruma` ซึ่งทำให้มีคุณสมบัติเพิ่มเติมในการทำงานกับ regex ที่เกินไปกว่าเครื่องยนต์ regex ภายในของ Ruby

ติดตั้งโดยใช้:

```bash
gem install oniguruma
```

ตัวอย่างการใช้งานอาจจะดูเหมือนนี้ (โดยสมมติว่าคุณได้เรียกร้อง `oniguruma` หลังจากติดตั้งเสร็จ):

```ruby
# นี่เป็นตัวอย่างขั้นสูงและอาจจำเป็นต้องตั้งค่าเพิ่มเติม
require 'oniguruma'

pattern = Oniguruma::ORegexp.new('(\d+)')
match_data = pattern.match("หมายเลขคือ 42.")
puts match_data[1]
# ผลลัพธ์: 42
```

จำไว้ว่า แม้ว่านิพจน์ปกติจะมีความสามารถมาก แต่ก็สามารถกลายเป็นความซับซ้อนและยากที่จะจัดการได้สำหรับรูปแบบที่ซับซ้อนมากขึ้น มุ่งเน้นไปที่ความสามารถในการอ่าน และพิจารณาวิธีการอื่น ๆ หาก regex ของคุณกลายเป็นเรื่องที่ซับซ้อนเกินไป
