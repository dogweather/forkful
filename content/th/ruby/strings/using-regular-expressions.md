---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:52:32.652725-06:00
description: "\u0E27\u0E34\u0E18\u0E35\u0E01\u0E32\u0E23: #."
lastmod: '2024-03-17T21:57:56.717681-06:00'
model: gpt-4-0125-preview
summary: '#.'
title: "\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E40\u0E23\u0E01\u0E38\u0E25\u0E32\u0E23\
  \u0E4C\u0E40\u0E2D\u0E47\u0E01\u0E40\u0E1E\u0E23\u0E2A\u0E0A\u0E31\u0E19"
weight: 11
---

## วิธีการ:


### การจับคู่พื้นฐาน
เพื่อจับคู่สตริงกับรูปแบบง่าย ๆ คุณสามารถใช้เมธอด `match` ด้านล่าง เรากำลังตรวจสอบว่าคำว่า "Ruby" มีอยู่ในสตริงที่กำหนดหรือไม่

```ruby
if /Ruby/.match("Hello, Ruby!")
  puts "พบการจับคู่!"
end
# ผลลัพธ์: พบการจับคู่!
```

### การจับคู่รูปแบบด้วยตัวแปร
คุณสามารถฝังตัวแปรเข้าไปใน regex ของคุณโดยใช้ไวยากรณ์ `#{}` ทำให้รูปแบบของคุณเป็นแบบไดนามิก

```ruby
language = "Ruby"
if /#{language}/.match("การเขียนโปรแกรมด้วย Ruby สนุก.")
  puts "พูดถึง Ruby!"
end
# ผลลัพธ์: พูดถึง Ruby!
```

### การใช้ Regex สำหรับการแทนที่
เมธอด `gsub` ช่วยให้คุณเปลี่ยนทุกครั้งที่ปรากฏรูปแบบด้วยสตริงที่ระบุเพื่อแทนที่

```ruby
puts "foobarfoo".gsub(/foo/, "bar")
# ผลลัพธ์: barbarbar
```

### การจับกลุ่ม
วงเล็บใน regex ใช้สำหรับการจับกลุ่มส่วนหนึ่งของการจับคู่ เมธอด `match` จะคืนค่าวัตถุ `MatchData` ซึ่งคุณสามารถใช้เพื่อเข้าถึงการจับกลุ่ม

```ruby
match_data = /(\w+): (\d+)/.match("อายุ: 30")
puts match_data[1] # ป้ายกำกับที่จับกลุ่ม
puts match_data[2] # ค่าที่จับกลุ่ม
# ผลลัพธ์:
# อายุ
# 30
```

### การใช้ไลบรารีของบุคคลที่สาม
แม้ว่าไลบรารีมาตรฐานของ Ruby จะมีพลังมาก คุณอาจต้องการความสามารถพิเศษบางอย่างบ้างเป็นบางครั้ง หนึ่งใน gem ยอดนิยมสำหรับการทำงานกับ regex คือ `Oniguruma` ซึ่งทำให้มีคุณสมบัติเพิ่มเติมในการทำงานกับ regex ที่เกินไปกว่าเครื่องยนต์ regex ภายในของ Ruby

ติดตั้งโดยใช้:

```bash
gem install oniguruma
```

ตัวอย่างการใช้งานอาจจะดูเหมือนนี้ (โดยสมมติว่าคุณได้เรียกร้อง `oniguruma` หลังจากติดตั้งเสร็จ):

```ruby
# นี่เป็นตัวอย่างขั้นสูงและอาจจำเป็นต้องตั้งค่าเพิ่มเติม
require 'oniguruma'

pattern = Oniguruma::ORegexp.new('(\d+)')
match_data = pattern.match("หมายเลขคือ 42.")
puts match_data[1]
# ผลลัพธ์: 42
```

จำไว้ว่า แม้ว่านิพจน์ปกติจะมีความสามารถมาก แต่ก็สามารถกลายเป็นความซับซ้อนและยากที่จะจัดการได้สำหรับรูปแบบที่ซับซ้อนมากขึ้น มุ่งเน้นไปที่ความสามารถในการอ่าน และพิจารณาวิธีการอื่น ๆ หาก regex ของคุณกลายเป็นเรื่องที่ซับซ้อนเกินไป
