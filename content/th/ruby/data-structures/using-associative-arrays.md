---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:52:35.250544-06:00
description: "\u0E41\u0E2D\u0E2A\u0E42\u0E0B\u0E0B\u0E35\u0E40\u0E2D\u0E17\u0E35\u0E1F\
  \u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C \u0E2B\u0E23\u0E37\u0E2D\u0E17\u0E35\
  \u0E48\u0E40\u0E23\u0E35\u0E22\u0E01\u0E01\u0E31\u0E19\u0E21\u0E32\u0E01\u0E01\u0E27\
  \u0E48\u0E32\u0E43\u0E19 Ruby \u0E04\u0E37\u0E2D \u0E41\u0E2E\u0E0A, \u0E0A\u0E48\
  \u0E27\u0E22\u0E43\u0E2B\u0E49\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E08\u0E31\u0E1A\
  \u0E04\u0E39\u0E48\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E0B\
  \u0E49\u0E33\u0E01\u0E31\u0E19\u0E01\u0E31\u0E1A\u0E04\u0E48\u0E32\u0E44\u0E14\u0E49\
  \u2026"
lastmod: '2024-03-17T21:57:56.720409-06:00'
model: gpt-4-0125-preview
summary: "\u0E41\u0E2D\u0E2A\u0E42\u0E0B\u0E0B\u0E35\u0E40\u0E2D\u0E17\u0E35\u0E1F\
  \u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C \u0E2B\u0E23\u0E37\u0E2D\u0E17\u0E35\
  \u0E48\u0E40\u0E23\u0E35\u0E22\u0E01\u0E01\u0E31\u0E19\u0E21\u0E32\u0E01\u0E01\u0E27\
  \u0E48\u0E32\u0E43\u0E19 Ruby \u0E04\u0E37\u0E2D \u0E41\u0E2E\u0E0A, \u0E0A\u0E48\
  \u0E27\u0E22\u0E43\u0E2B\u0E49\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16\u0E08\u0E31\u0E1A\
  \u0E04\u0E39\u0E48\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E0B\
  \u0E49\u0E33\u0E01\u0E31\u0E19\u0E01\u0E31\u0E1A\u0E04\u0E48\u0E32\u0E44\u0E14\u0E49\
  \ \u0E1E\u0E27\u0E01\u0E21\u0E31\u0E19\u0E40\u0E1B\u0E47\u0E19\u0E2A\u0E34\u0E48\
  \u0E07\u0E08\u0E33\u0E40\u0E1B\u0E47\u0E19\u0E40\u0E21\u0E37\u0E48\u0E2D\u0E04\u0E38\
  \u0E13\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E15\u0E34\u0E14\u0E15\u0E32\u0E21\
  \u0E2D\u0E07\u0E04\u0E4C\u0E1B\u0E23\u0E30\u0E01\u0E2D\u0E1A\u0E1C\u0E48\u0E32\u0E19\
  \u0E01\u0E32\u0E23\u0E2D\u0E49\u0E32\u0E07\u0E2D\u0E34\u0E07\u0E40\u0E09\u0E1E\u0E32\
  \u0E30 \u0E40\u0E0A\u0E48\u0E19 \u0E01\u0E32\u0E23\u0E40\u0E01\u0E47\u0E1A\u0E04\
  \u0E38\u0E13\u0E2A\u0E21\u0E1A\u0E31\u0E15\u0E34\u0E02\u0E2D\u0E07\u0E27\u0E31\u0E15\
  \u0E16\u0E38\u0E2B\u0E23\u0E37\u0E2D\u0E01\u0E32\u0E23\u0E40\u0E02\u0E49\u0E32\u0E16\
  \u0E36\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E23\
  \u0E27\u0E14\u0E40\u0E23\u0E47\u0E27\u0E42\u0E14\u0E22\u0E43\u0E0A\u0E49\u0E15\u0E31\
  \u0E27\u0E15\u0E19\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E0B\u0E49\u0E33\u0E43\u0E04\
  \u0E23."
title: "\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E41\u0E2D\u0E40\u0E23\u0E22\u0E4C\u0E2A\
  \u0E21\u0E32\u0E0A\u0E34\u0E01"
weight: 15
---

## มันคืออะไร & ทำไมถึงต้องใช้?

แอสโซซีเอทีฟอาร์เรย์ หรือที่เรียกกันมากกว่าใน Ruby คือ แฮช, ช่วยให้สามารถจับคู่คีย์ที่ไม่ซ้ำกันกับค่าได้ พวกมันเป็นสิ่งจำเป็นเมื่อคุณต้องการติดตามองค์ประกอบผ่านการอ้างอิงเฉพาะ เช่น การเก็บคุณสมบัติของวัตถุหรือการเข้าถึงข้อมูลอย่างรวดเร็วโดยใช้ตัวตนที่ไม่ซ้ำใคร

## วิธีการ:

การสร้างและใช้แฮชใน Ruby นั้นง่ายดาย คุณสามารถเริ่มต้นด้วยแฮชว่างๆ, เติมคู่คีย์-ค่า, เข้าถึงค่าด้วยคีย์ของมัน, และอื่นๆ นี่คือวิธีที่คุณทำ:

```Ruby
# การสร้างแฮช
my_hash = { "name" => "John Doe", "age" => 30 }

# อีกวิธีหนึ่งในการสร้างแฮช
another_hash = Hash.new
another_hash["position"] = "Developer"

# การเข้าถึงค่าในแฮช
puts my_hash["name"] # ผลลัพธ์: John Doe

# เพิ่มคู่คีย์-ค่าใหม่
my_hash["language"] = "Ruby"
puts my_hash # ผลลัพธ์: {"name"=>"John Doe", "age"=>30, "language"=>"Ruby"}

# การวนซ้ำผ่านแฮช
my_hash.each do |key, value|
  puts "#{key}: #{value}"
end
# ผลลัพธ์:
# name: John Doe
# age: 30
# language: Ruby
```

คุณยังสามารถใช้สัญลักษณ์เป็นคีย์ที่มีประสิทธิภาพมากขึ้น:

```Ruby
# ใช้สัญลักษณ์สำหรับคีย์
symbol_hash = { name: "Jane Doe", age: 22 }
puts symbol_hash[:name] # ผลลัพธ์: Jane Doe
```

## ลงลึก:

แนวคิดของแอสโซซีเอทีฟอาร์เรย์ไม่ใช่เฉพาะเฉพาะของ Ruby; หลายภาษาได้ดำเนินการใช้งานภายใต้ชื่อต่างๆ, เช่น ดิกชันนารีใน Python หรืออ็อบเจคใน JavaScript (เมื่อใช้เป็นคู่คีย์-ค่า) ในช่วงแรกๆ ของ Ruby, แฮชมักจะช้าและไม่หลากหลายเท่าที่ควร อย่างไรก็ตาม, ตามเวลาที่ผ่านไป, การดำเนินการแฮชของ Ruby ได้ถูกปรับให้มีความเหมาะสมอย่างมาก, โดยเฉพาะสำหรับคีย์สัญลักษณ์, ทำให้มีประสิทธิภาพสูงสำหรับการเข้าถึงและอัพเดตอย่างถี่ถ้วน

แฮชของ Ruby โดดเด่นด้วยความง่ายดายในด้านไวยากรณ์การใช้งานและความยืดหยุ่น - คุณสามารถใช้วัตถุประเภทเกือบใดๆ เป็นคีย์ได้, ถึงแม้ว่าสัญลักษณ์และสตริงจะเป็นที่นิยมมากที่สุด ภายใน, แฮชของ Ruby ได้ถูกดำเนินการโดยใช้อัลกอริทึมแฮชชิ่งที่จัดสรรความเร็วและประสิทธิภาพของหน่วยความจำอย่างสมดุล, แม้ว่าจำนวนองค์ประกอบจะเพิ่มขึ้น

ต่อให้แฮชมีความหลากหลายอย่างยิ่งใหญ่, พวกมันไม่ใช่คำตอบสุดท้ายสำหรับการเก็บข้อมูลใน Ruby สำหรับคอลเลกชันที่มีการเรียงลำดับ, อาร์เรย์จะเหมาะสมกว่า, และสำหรับชุดของรายการที่ไม่ซ้ำกัน, Set อาจจะเป็นทางเลือกที่ดีกว่า นอกจากนี้, สำหรับโครงสร้างข้อมูลที่ซับซ้อนมาก, การสร้างคลาสที่กำหนดเองอาจจะเป็นทางเลือกที่ควรพิจารณา

จำไว้, การเลือกใช้แฮชเทียบกับโครงสร้างข้อมูลอื่นๆ ส่วนใหญ่ขึ้นอยู่กับกรณีการใช้งานเฉพาะ—แฮชโดดเด่นในการค้นหาอย่างรวดเร็วและการรักษาความสัมพันธ์ระหว่างคีย์ที่ไม่ซ้ำกับค่าของมัน
