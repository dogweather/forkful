---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:52:12.189893-06:00
description: "Interactive shell \u0E2B\u0E23\u0E37\u0E2D Read-Eval-Print Loop (REPL)\
  \ \u0E0A\u0E48\u0E27\u0E22\u0E43\u0E2B\u0E49\u0E04\u0E38\u0E13\u0E17\u0E14\u0E25\
  \u0E2D\u0E07\u0E01\u0E31\u0E1A\u0E42\u0E04\u0E49\u0E14 Go \u0E44\u0E14\u0E49\u0E41\
  \u0E1A\u0E1A\u0E40\u0E23\u0E35\u0E22\u0E25\u0E44\u0E17\u0E21\u0E4C \u0E14\u0E49\u0E27\
  \u0E22\u0E01\u0E32\u0E23\u0E23\u0E31\u0E19\u0E04\u0E33\u0E2A\u0E31\u0E48\u0E07\u0E41\
  \u0E25\u0E30\u0E23\u0E31\u0E1A\u0E1F\u0E35\u0E14\u0E41\u0E1A\u0E47\u0E04\u0E17\u0E31\
  \u0E19\u0E17\u0E35\u2026"
lastmod: '2024-03-17T21:57:55.674148-06:00'
model: gpt-4-0125-preview
summary: "Interactive shell \u0E2B\u0E23\u0E37\u0E2D Read-Eval-Print Loop (REPL) \u0E0A\
  \u0E48\u0E27\u0E22\u0E43\u0E2B\u0E49\u0E04\u0E38\u0E13\u0E17\u0E14\u0E25\u0E2D\u0E07\
  \u0E01\u0E31\u0E1A\u0E42\u0E04\u0E49\u0E14 Go \u0E44\u0E14\u0E49\u0E41\u0E1A\u0E1A\
  \u0E40\u0E23\u0E35\u0E22\u0E25\u0E44\u0E17\u0E21\u0E4C \u0E14\u0E49\u0E27\u0E22\u0E01\
  \u0E32\u0E23\u0E23\u0E31\u0E19\u0E04\u0E33\u0E2A\u0E31\u0E48\u0E07\u0E41\u0E25\u0E30\
  \u0E23\u0E31\u0E1A\u0E1F\u0E35\u0E14\u0E41\u0E1A\u0E47\u0E04\u0E17\u0E31\u0E19\u0E17\
  \u0E35\u2026"
title: "\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49 Shell \u0E41\u0E1A\u0E1A\u0E42\u0E15\u0E49\
  \u0E15\u0E2D\u0E1A (REPL)"
---

{{< edit_this_page >}}

## อะไร & ทำไม?

Interactive shell หรือ Read-Eval-Print Loop (REPL) ช่วยให้คุณทดลองกับโค้ด Go ได้แบบเรียลไทม์ ด้วยการรันคำสั่งและรับฟีดแบ็คทันที วิธีนี้ถูกใช้กันอย่างแพร่หลายสำหรับการเรียนรู้ การดีบัก และการสร้างต้นแบบ เนื่องจากมันข้ามขั้นตอนการเขียน-คอมไพล์-รันแบบดั้งเดิมได้ ทำให้กระบวนการพัฒนาเร็วขึ้นและมีสัญชาตญาณมากขึ้น

## วิธีการ:

แม้ Go จะไม่มี REPL ติดตั้งมาด้วย แต่ชุมชนได้สร้างเครื่องมือเช่น `gore` เพื่อเติมเต็มช่องว่างนี้ ขั้นแรก ติดตั้ง `gore` โดยรัน:

```
$ go get -u github.com/motemen/gore
```

เมื่อติดตั้งเสร็จ ให้เปิด `gore` โดยพิมพ์ `gore` ในเทอร์มินัลของคุณ:

```
$ gore
```

คุณควรจะเห็นพร้อมต์พร้อมที่จะรับคำสั่ง Go ลองดูตัวอย่างง่ายๆ:

```
gore> :import fmt
gore> fmt.Println("Hello, Go REPL!")
```

คุณจะเห็นผลลัพธ์เช่น:

```
Hello, Go REPL!
```

การสร้างตัวแปรและนิยามฟังก์ชันทำงานตามที่คาดหวังได้ คุณสามารถประกาศฟังก์ชันได้:

```
gore> :import math
gore> areaCircle := func(radius float64) float64 {
...> return math.Pi * radius * radius
...> }
gore> fmt.Println("พื้นที่วงกลมที่มีรัศมี 4:", areaCircle(4))
```

และรับผลลัพธ์ทันที:

```
พื้นที่วงกลมที่มีรัศมี 4: 50.26548245743669
```

## ลงลึก:

ความคิดของ REPL นั้นเป็นที่เก่าแก่ ย้อนกลับไปถึงเครื่อง Lisp ในยุค 1960s ซึ่งให้ประสบการณ์การเขียนโปรแกรมแบบโต้ตอบ ต่างจากภาษาอย่าง Python หรือ JavaScript Go ถูกออกแบบมาโดยไม่มี REPL โดยโฟกัสไปที่ไบนารีที่คอมไพล์สำหรับประสิทธิภาพและความเรียบง่าย นี่สะท้อนถึงปรัชญาของ Go ที่เน้นความเรียบง่าย และการออกแบบเพื่อซอฟต์แวร์ที่ขยายขนาดได้และรักษาความได้

อย่างไรก็ตาม เครื่องมือเช่น `gore` หรือ `goplay` แสดงให้เห็นถึงความคล่องตัวของชุมชน Go ในการเชื่อมโยงช่องว่างนี้ เครื่องมือเหล่านี้วิเคราะห์โค้ด Go แบบไดนามิคและใช้แพ็กเกจ `go/eval` หรือกลไกคล้ายคลึงกันเพื่อรันมันแบบเรียลไทม์ แม้ว่าจะมีข้อจำกัดบ้างเมื่อเทียบกับสภาพแวดล้อม REPL ท้องถิ่น ข้อจำกัดเหล่านี้เกิดจากระบบประเภทและโมเดลการคอมไพล์ของ Go ซึ่งอาจทำให้การประเมินค่าแบบทันทีเป็นเรื่องยาก

ในขณะที่สภาพแวดล้อม REPL มีประโยชน์อย่างยิ่งสำหรับการศึกษาและการทดสอบอย่างรวดเร็ว ระบบนิเวศ Go โดยปกติแล้วจะเอนเอียงไปที่กระบวนการคอมไพล์และรันแบบดั้งเดิมสำหรับงานพัฒนาส่วนใหญ่ IDE และเอดิเตอร์ที่รองรับ Go เช่น Visual Studio Code หรือ GoLand นำเสนอเครื่องมือที่รวมอยู่แล้วสำหรับการทดสอบและการดีบักที่บรรเทาความต้องการของ REPL สำหรับการพัฒนามืออาชีพ

สำหรับการเขียนโปรแกรมที่สำรวจ การสร้างต้นแบบ หรือการเรียนรู้ อย่างไรก็ตาม REPL อย่าง `gore` นำเสนอทางเลือกที่มีค่า ช่วยให้โปรแกรมเมอร์ที่ชินกับ REPL ในภาษาอื่นได้สัมผัสประสบการณ์ที่คล้ายคลึงใน Go
