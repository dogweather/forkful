---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:49:07.215861-06:00
description: "\u0E27\u0E34\u0E18\u0E35\u0E17\u0E33: \u0E19\u0E35\u0E48\u0E04\u0E37\
  \u0E2D\u0E2A\u0E48\u0E27\u0E19\u0E02\u0E2D\u0E07\u0E42\u0E04\u0E49\u0E14 Elm \u0E1E\
  \u0E23\u0E49\u0E2D\u0E21\u0E1F\u0E31\u0E07\u0E01\u0E4C\u0E0A\u0E31\u0E19\u0E07\u0E48\
  \u0E32\u0E22\u0E46 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E01\u0E32\u0E23\u0E17\u0E31\
  \u0E01\u0E17\u0E32\u0E22\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49."
lastmod: '2024-03-17T21:57:56.134473-06:00'
model: gpt-4-0125-preview
summary: "\u0E19\u0E35\u0E48\u0E04\u0E37\u0E2D\u0E2A\u0E48\u0E27\u0E19\u0E02\u0E2D\
  \u0E07\u0E42\u0E04\u0E49\u0E14 Elm \u0E1E\u0E23\u0E49\u0E2D\u0E21\u0E1F\u0E31\u0E07\
  \u0E01\u0E4C\u0E0A\u0E31\u0E19\u0E07\u0E48\u0E32\u0E22\u0E46 \u0E2A\u0E33\u0E2B\u0E23\
  \u0E31\u0E1A\u0E01\u0E32\u0E23\u0E17\u0E31\u0E01\u0E17\u0E32\u0E22\u0E1C\u0E39\u0E49\
  \u0E43\u0E0A\u0E49."
title: "\u0E01\u0E32\u0E23\u0E08\u0E31\u0E14\u0E23\u0E30\u0E40\u0E1A\u0E35\u0E22\u0E1A\
  \u0E42\u0E04\u0E49\u0E14\u0E40\u0E02\u0E49\u0E32\u0E44\u0E1B\u0E43\u0E19\u0E1F\u0E31\
  \u0E07\u0E01\u0E4C\u0E0A\u0E31\u0E19"
weight: 18
---

## วิธีทำ:
นี่คือส่วนของโค้ด Elm พร้อมฟังก์ชันง่ายๆ สำหรับการทักทายผู้ใช้:

```Elm
module Main exposing (..)

import Html exposing (text)

greetUser : String -> String
greetUser userName =
    "Hello, " ++ userName ++ "!"

main =
    text (greetUser "Casey")
```

เมื่อรัน คุณจะได้ผลลัพธ์: "Hello, Casey!"

ตอนนี้ ลองพูดว่าคุณต้องการเพิ่มการปรับแต่งเป็นส่วนตัว เพิ่มฟังก์ชันมากขึ้น!

```Elm
module Main exposing (..)

import Html exposing (text)

greetUser : String -> String -> String
greetUser greeting userName =
    greeting ++ ", " ++ userName ++ "!"

personalGreeting : String -> String
personalGreeting userName =
    greetUser "Howdy" userName

main =
    text (personalGreeting "Casey")
```

ตอนนี้ เมื่อคุณรัน: "Howdy, Casey!" มีเวทมนตร์หรือ? ไม่หรอก แค่ฟังก์ชันกำลังทำงานของมัน

## ลงลึกขึ้น
ในยุคสมัยก่อน โค้ดมักจะเป็นลำดับคำสั่งยาวๆ (คิดถึงโค้ดขั้นสปาเกตตี้) มันเป็นฝันร้ายในการดูแล จากนั้นการเขียนโปรแกรมแบบมีโครงสร้างก็เข้ามา และก็มีฟังก์ชัน โปรแกรม Elm เช่นเดียวกับบรรพบุรุษการเขียนโปรแกรมแบบฟังก์ชันขึ้นอยู่กับฟังก์ชันอย่างหนักในการจัดระเบียบ

คุณสามารถซ้อนฟังก์ชัน เพื่อสร้างการปิด หรือรักษาความเรียบง่ายด้วยฟังก์ชันบริสุทธิ์ Elm สนับสนุนสิ่งหลัง: ฟังก์ชันบริสุทธิ์พร้อมอินพุตและเอาท์พุตที่กำหนดไว้อย่างชัดเจน นำไปสู่การแก้ไขบั๊กและการทดสอบที่ง่ายขึ้น

ฟังก์ชันใน Elm ยังสามารถเป็นฟังก์ชันชั้นสูง หมายความว่าสามารถยอมรับหรือส่งคืนฟังก์ชันอื่น ความสามารถนี้เปิดโลกของการรวมกัน อย่างไรก็ตาม ไม่เหมือนกับภาษาอื่นๆ Elm ไม่มีการโหลดฟังก์ชันในแบบต่างๆ; ทุกฟังก์ชันต้องมีชื่อที่ไม่ซ้ำกัน

นอกจากนี้ Elm ยังบังคับระบบการประเภทแบบเข้มงวดที่ไม่เพียงแต่ตรวจสอบประเภท แต่ยังสามารถแนะนำได้ด้วย ลดโค้ดที่ซ้ำซาก

เมื่อเทียบกับทางเลือกอื่นๆ เช่นระบบการจัดระเบียบโค้ดแบบวิธีการหรือวัตถุในภาษาอื่น Elm มุ่งเน้นที่ความเรียบง่ายและความสามารถในการคาดการณ์ Elm ไม่มีวัตถุหรือคลาส คุณจัดระเบียบโค้ดด้วยฟังก์ชันและโมดูลแทนคลาสและอินสแตนซ์

## ดูเพิ่มเติม
ต้องการศึกษาเพิ่มเติม ดูทรัพยากรเหล่านี้:
- คู่มืออย่างเป็นทางการของ Elm เกี่ยวกับฟังก์ชัน: https://guide.elm-lang.org/core_language.html
- เอกสารการใช้งานแพคเกจของ Elm สำหรับตัวอย่างฟังก์ชันที่ซับซ้อนมากขึ้น: https://package.elm-lang.org/
- เรียนรู้เกี่ยวกับระบบการประเภทของ Elm ซึ่งทำงานร่วมกับการจัดระเบียบฟังก์ชันได้อย่างดี: https://elm-lang.org/docs/types
