---
title:                "एक टेक्स्ट फ़ाइल लिखना"
aliases: - /hi/go/writing-a-text-file.md
date:                  2024-02-03T18:16:34.188504-07:00
model:                 gpt-4-0125-preview
simple_title:         "एक टेक्स्ट फ़ाइल लिखना"
tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/go/writing-a-text-file.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?

Go में एक टेक्स्ट फाइल लिखना एक नई या मौजूदा टेक्स्ट फाइल में डेटा के स्ट्रिंग्स बनाने और लिखने की प्रक्रिया शामिल करता है। प्रोग्रामर इसे डेटा को संवारने के लिए करते हैं, जैसे कि एप्लिकेशन लॉग्स, कॉन्फिगरेशन सेटिंग्स, या डेटा प्रोसेसिंग कार्यों से आउटपुट, जो सॉफ्टवेयर विकास में डेटा प्रबंधन और रिपोर्टिंग के लिए एक मौलिक कौशल बनाता है।

## कैसे:

Go में टेक्स्ट फाइल में लिखना `os` और `io/ioutil` (Go के संस्करण < 1.16) या `os` और `io` प्लस `os` पैकेजों द्वारा Go 1.16 और उससे ऊपर के लिए, सादगी और कुशलता के Go के दर्शन को दर्शाता है। नया API सरल त्रुटि हैंडलिंग के साथ बेहतर प्रथाओं को बढ़ावा देता है। आइए देखें कि Go के `os` पैकेज का उपयोग करके टेक्स्ट फाइल बनाने और उसमें लिखने के लिए कैसे आगे बढ़ें।

सबसे पहले, यह सुनिश्चित करें कि आपका Go वातावरण सेटअप किया गया है और तैयार है। फिर, एक `.go` फ़ाइल बनाएँ, उदाहरण के लिए, `writeText.go`, और इसे अपने टेक्स्ट एडिटर या IDE में खोलें।

यहाँ एक सरल उदाहरण है जो एक फ़ाइल नाम `example.txt` में एक स्ट्रिंग लिखता है:

```go
package main

import (
    "os"
    "log"
)

func main() {
    content := []byte("Hello, Wired readers!\n")

    // फ़ाइल example.txt बनाएं या उसपर लिखें
    err := os.WriteFile("example.txt", content, 0644)
    if err != nil {
        log.Fatal(err)
    }
}

```

जब आप इस कोड को `go run writeText.go` का उपयोग करके चलाते हैं, यह एक फ़ाइल नामित `example.txt` बनाएगा (या यदि यह पहले से मौजूद है तो इसे ओवरराइट करेगा) जिसकी सामग्री "Hello, Wired readers!" होगी।

### एक फ़ाइल में जोड़ना

अगर आप सामग्री में जोड़ना चाहते हैं तो क्या होगा? Go इसे संभालने के लिए एक लचीला तरीका प्रदान करता है:

```go
file, err := os.OpenFile("example.txt", os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0644)
if err != nil {
    log.Fatal(err)
}
defer file.Close()

if _, err := file.WriteString("Appending more text.\n"); err != nil {
    log.Fatal(err)
}
```

यह टुकड़ा `example.txt` को ऐपेंड मोड में खोलता है, एक अद्यतन लाइन लिखता है, और सुनिश्चित करता है कि फाइल ठीक से बंद हो जाए भले ही कोई त्रुटि हो। 

## गहराई से विचार

Go के फाइल हैंडलिंग के दृष्टिकोण का विकास इसके कोड सादगी और कुशलता के प्रति व्यापक प्रतिबद्धता को दर्शाता है। प्रारंभिक संस्करणों में `ioutil` पैकेज पर अधिक निर्भरता थी, जिससे थोड़ी अधिक शब्दावली और त्रुटियों की थोड़ी अधिक संभावना थी। `os` और `io` पैकेजों में, विशेष रूप से संस्करण 1.16 से शुरू होकर, फाइल ऑपरेशनों को सरलीकृत करने की दिशा में Go के सक्रिय कदमों को दर्शाता है, और अधिक सुसंगत त्रुटि हैंडलिंग को प्रोत्साहित करता है, और भाषा को और अधिक सुलभ बनाता है।

जबकि Go की अंतर्निहित लाइब्रेरी कई उपयोग के मामलों के लिए पर्याप्त है, कुछ परिस्थितियों में वैकल्पिक पैकेजों या बाहरी लाइब्रेरीज़ को पसंद किया जा सकता है, विशेष रूप से अधिक जटिल फाइल ऑपरेशनों के लिए या जब बड़े फ्रेमवर्कों के भीतर काम करते हैं जो फाइल हैंडलिंग के लिए अपने विशिष्ट अमूर्तन प्रदान करते हैं। हालाँकि, सीधे, सरल फाइल लेखन कार्यों के लिए, मानक पुस्तकालय अक्सर Go प्रोग्रामिंग में सबसे कुशल और मौलिक मार्ग प्रदान करता है। फाइल ऑपरेशनों के लिए सरल, अधिक संगठित APIs की ओर संक्रमण न केवल Go कोड को लिखने और बनाए रखने में आसान बनाता है, बल्कि भाषा के सादगी, पठनीयता, और व्यावहारिक दर्शन को भी मजबूत करता है।
