---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:58:32.561680-07:00
description: "Go \u092E\u0947\u0902 \u090F\u0915 \u0938\u094D\u091F\u094D\u0930\u093F\
  \u0902\u0917 \u0915\u0940 \u0932\u0902\u092C\u093E\u0908 \u0922\u0942\u0901\u0922\
  \u0928\u093E \u0907\u0938\u0915\u0947 \u0905\u0915\u094D\u0937\u0930\u094B\u0902\
  \ \u0915\u0940 \u0938\u0902\u0916\u094D\u092F\u093E \u0928\u093F\u0930\u094D\u0927\
  \u093E\u0930\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0935\u093F\u0937\
  \u092F \u092E\u0947\u0902 \u0939\u0948\u0964 \u092A\u094D\u0930\u094B\u0917\u094D\
  \u0930\u093E\u092E\u0930 \u0928\u093F\u092F\u092E\u093F\u0924 \u0930\u0942\u092A\
  \ \u0938\u0947 \u0907\u0938 \u0911\u092A\u0930\u0947\u0936\u0928 \u0915\u094B \u0938\
  \u094D\u091F\u094D\u0930\u093F\u0902\u0917\u094D\u0938 \u0915\u094B \u092A\u094D\
  \u0930\u092D\u093E\u0935\u0940 \u0930\u0942\u092A\u2026"
lastmod: 2024-02-19 22:05:10.469999
model: gpt-4-0125-preview
summary: "Go \u092E\u0947\u0902 \u090F\u0915 \u0938\u094D\u091F\u094D\u0930\u093F\u0902\
  \u0917 \u0915\u0940 \u0932\u0902\u092C\u093E\u0908 \u0922\u0942\u0901\u0922\u0928\
  \u093E \u0907\u0938\u0915\u0947 \u0905\u0915\u094D\u0937\u0930\u094B\u0902 \u0915\
  \u0940 \u0938\u0902\u0916\u094D\u092F\u093E \u0928\u093F\u0930\u094D\u0927\u093E\
  \u0930\u093F\u0924 \u0915\u0930\u0928\u0947 \u0915\u0947 \u0935\u093F\u0937\u092F\
  \ \u092E\u0947\u0902 \u0939\u0948\u0964 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\
  \u093E\u092E\u0930 \u0928\u093F\u092F\u092E\u093F\u0924 \u0930\u0942\u092A \u0938\
  \u0947 \u0907\u0938 \u0911\u092A\u0930\u0947\u0936\u0928 \u0915\u094B \u0938\u094D\
  \u091F\u094D\u0930\u093F\u0902\u0917\u094D\u0938 \u0915\u094B \u092A\u094D\u0930\
  \u092D\u093E\u0935\u0940 \u0930\u0942\u092A\u2026"
title: "\u0938\u094D\u091F\u094D\u0930\u093F\u0902\u0917 \u0915\u0940 \u0932\u0902\
  \u092C\u093E\u0908 \u0915\u093E \u092A\u0924\u093E \u0932\u0917\u093E\u0928\u093E"
---

{{< edit_this_page >}}

## क्या और क्यों?
Go में एक स्ट्रिंग की लंबाई ढूँढना इसके अक्षरों की संख्या निर्धारित करने के विषय में है। प्रोग्रामर नियमित रूप से इस ऑपरेशन को स्ट्रिंग्स को प्रभावी रूप से संचालित करने के लिए करते हैं, चाहे वह मान्यीकरण के लिए, उपस्ट्रिंग निष्कर्षण के लिए, या केवल उपयोगकर्ता इनपुट में प्रतिबंध लागू करने के लिए हो।

## कैसे:
Go में, स्ट्रिंग्स को अपरिवर्तनीय बाइट्स श्रृंखला के रूप में माना जाता है। आप एक स्ट्रिंग की लंबाई `len()` निर्मित-इन फ़ंक्शन का उपयोग करके पा सकते हैं जो बाइट्स की संख्या लौटाता है, जरूरी नहीं के अक्षरों की संख्या। इसका उपयोग कैसे करें:

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// len() का उपयोग करके बाइट लंबाई ढूँढना
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("बाइट लंबाई:", byteLength) // आउटपुट: बाइट लंबाई: 13

	// स्ट्रिंग में अक्षरों या रून्स की संख्या सही ढंग से पाने के लिए
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("रून लंबाई:", runeLength) // आउटपुट: रून लंबाई: 9
}
```
`len()` का उपयोग करने वाली पहली विधि हमेशा अपेक्षित परिणाम नहीं दे सकती है क्योंकि यह बाइट्स को गिनती है। गैर-ASCII अक्षरों ("世界" जैसे) वाली स्ट्रिंग्स के लिए `unicode/utf8` पैकेज से `RuneCountInString` का उपयोग करना चाहिए जिससे Unicode कोड पॉइंट को सही तरीके से गिना जा सके।

## गहराई में
Go 1 से पहले, बाइट्स के अनुक्रमों के विपरीत अक्षरों के अनुक्रमों को संभालने के लिए कोई सख्त विभाजन नहीं था। Go 1 के बाद, स्ट्रिंग्स के लिए मानक एन्कोडिंग योजना के रूप में UTF-8 की अपनाई जाने की आवश्यकता ने स्पष्ट दृष्टिकोणों की मांग की। ASCII स्ट्रिंग्स के लिए `len()` फ़ंक्शन बिल्कुल सही है, जहाँ अक्षर एक ही बाइट में प्रतिनिधित्व किए जाते हैं। हालाँकि, जैसे ही Go अनुप्रयोग अधिक वैश्विक बने, और भाषाओं और अक्षर सेटों की एक भरमार का समर्थन करने की जरूरत बढ़ी, `len()` का सरलीकृत दृष्टिकोण सीमित दिखाई दिया।

`utf8.RuneCountInString()` का परिचय और उपयोग इन सीमाओं का समाधान प्रदान करता है, जिससे वास्तविक Unicode अक्षरों (Go शब्दावली में रून्स) को गिनने का एक तरीका मिलता है। यह विधि यह सुनिश्चित करती है कि लंबाई की गणना UTF-8 के एन्कोडिंग विशिष्टताओं से स्वतंत्र हो, जहाँ अक्षर एकाधिक बाइट्स में फैले हो सकते हैं।

Go की समानांतरता और कुशलता की भावना के अनुरूप, स्ट्रिंग्स को रून्स की स्लाइस के रूप में मानना और प्रतिपादन करना, एक वैकल्पिक दृष्टिकोण हो सकता है। हालांकि, यह विधि एक रूपांतरण चरण की आवश्यकता होती है और यह तुरंत Unicode की सभी जटिलताओं को हल नहीं करती है (जैसे, संयोजक अक्षर)।

सारांश में, जबकि `len()` बाइट लंबाई के लिए उपयुक्त है और ASCII पाठ के लिए कुशल है, `utf8.RuneCountInString()` एक विश्वसनीय विकल्प है एक वैश्विक रूप से संगत अनुप्रयोग के लिए। फिर भी, विकासकर्ताओं को इन विकल्पों के साथ आने वाले प्रदर्शन और मेमोरी उपयोग में व्यापार-बंद को समझने के लिए प्रोत्साहित किया जाता है।
