---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:16:15.165434-07:00
description: "\u0915\u0948\u0938\u0947: C \u092E\u0947\u0902 \u090F\u0915 \u092B\u093C\
  \u093E\u0907\u0932 \u092E\u0947\u0902 \u091F\u0947\u0915\u094D\u0938\u094D\u091F\
  \ \u0932\u093F\u0916\u0928\u0947 \u0915\u0947 \u0932\u093F\u090F, \u0906\u092A\u0915\
  \u094B \u092E\u0941\u0916\u094D\u092F \u0930\u0942\u092A \u0938\u0947 `fopen()`,\
  \ `fprintf()`, `fputs()`, \u0914\u0930 `fclose()` \u092B\u093C\u0902\u0915\u094D\
  \u0936\u0928\u094D\u0938 \u0938\u0947 \u092A\u0930\u093F\u091A\u093F\u0924 \u0939\
  \u094B\u0928\u093E \u091A\u093E\u0939\u093F\u090F\u0964 \u0928\u0940\u091A\u0947\
  \ \u090F\u0915\u2026"
lastmod: '2024-03-13T22:44:53.178358-06:00'
model: gpt-4-0125-preview
summary: "C \u092E\u0947\u0902 \u090F\u0915 \u092B\u093C\u093E\u0907\u0932 \u092E\u0947\
  \u0902 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u0932\u093F\u0916\u0928\u0947\
  \ \u0915\u0947 \u0932\u093F\u090F, \u0906\u092A\u0915\u094B \u092E\u0941\u0916\u094D\
  \u092F \u0930\u0942\u092A \u0938\u0947 `fopen()`, `fprintf()`, `fputs()`, \u0914\
  \u0930 `fclose()` \u092B\u093C\u0902\u0915\u094D\u0936\u0928\u094D\u0938 \u0938\u0947\
  \ \u092A\u0930\u093F\u091A\u093F\u0924 \u0939\u094B\u0928\u093E \u091A\u093E\u0939\
  \u093F\u090F\u0964 \u0928\u0940\u091A\u0947 \u090F\u0915 \u0938\u093E\u0927\u093E\
  \u0930\u0923 \u0909\u0926\u093E\u0939\u0930\u0923 \u0926\u093F\u092F\u093E \u0917\
  \u092F\u093E \u0939\u0948 \u091C\u094B \u090F\u0915 \u092B\u093C\u093E\u0907\u0932\
  \ \u092C\u0928\u093E\u0928\u0947 \u0914\u0930 \u0909\u0938\u092E\u0947\u0902 \u0932\
  \u093F\u0916\u0928\u0947 \u0915\u094B \u0926\u0930\u094D\u0936\u093E\u0924\u093E\
  \ \u0939\u0948."
title: "\u090F\u0915 \u091F\u0947\u0915\u094D\u0938\u094D\u091F \u092B\u093C\u093E\
  \u0907\u0932 \u0932\u093F\u0916\u0928\u093E"
weight: 24
---

## कैसे:
C में एक फ़ाइल में टेक्स्ट लिखने के लिए, आपको मुख्य रूप से `fopen()`, `fprintf()`, `fputs()`, और `fclose()` फ़ंक्शन्स से परिचित होना चाहिए। नीचे एक साधारण उदाहरण दिया गया है जो एक फ़ाइल बनाने और उसमें लिखने को दर्शाता है:

```c
#include <stdio.h>

int main() {
    FILE *filePointer;
    // एक फ़ाइल को लेखन मोड में खोलता है। यदि फ़ाइल मौजूद नहीं है, तो यह बना दी जाएगी।
    filePointer = fopen("example.txt", "w");
    
    if(filePointer == NULL) {
        printf("फ़ाइल नहीं खोली जा सकी\n");
        return 1; // यदि फ़ाइल पॉइंटर NULL लौटाया गया तो कार्यक्रम बाहर निकल जाएगा।
    }
    
    // फ़ाइल में लिखना
    fprintf(filePointer, "यह फ़ाइल में लिखने का एक उदाहरण है।\n");
    fputs("यहाँ एक और पंक्ति का टेक्स्ट है।\n", filePointer);
    
    // परिवर्तनों को सहेजने के लिए फ़ाइल बंद करना
    fclose(filePointer);
    
    printf("फ़ाइल सफलतापूर्वक लिखी गई\n");
    return 0;
}
```

सफल निष्पादन पर नमूना आउटपुट:
```
फ़ाइल सफलतापूर्वक लिखी गई
```

इस प्रोग्राम को चलाने के बाद, आपको समान निर्देशिका में `example.txt` नामक एक फ़ाइल मिलेगी, जिसमें `fprintf()` और `fputs()` के माध्यम से लिखा गया टेक्स्ट होगा।

## गहराई से:
फ़ाइलों और फ़ाइल सिस्टमों की अवधारणा कंप्यूटर सिस्टमों के लिए मौलिक रही है, जिनका प्रबंधन ऑपरेटिंग सिस्टमों का एक महत्वपूर्ण पहलू है। C में, फ़ाइलों को संभाला जाता है मानक I/O लाइब्रेरी फ़ंक्शन्स के एक सेट का उपयोग करके, जो फ़ाइलों को बाइट्स की धाराओं के रूप में व्यवहार करने की दर्शन पर आधारित है। यह अमूर्तन फ़ाइलों से पढ़ने और फ़ाइलों में लिखने का एक सीधा और कुशल तरीका प्रदान करता है, हालांकि यह पायथन या रूबी जैसी अधिक आधुनिक भाषाओं में उपलब्ध दृष्टिकोणों की तुलना में कम स्तरीय प्रतित हो सकता है।

ऐतिहासिक रूप से, C में ये फ़ाइल I/O ऑपरेशन कई प्रोग्रामिंग भाषाओं में फ़ाइल मैनिपुलेशन के लिए आधार रखते हैं, जिसमें ऑपरेटिंग सिस्टम के फ़ाइल प्रबंधन सिस्टमों के साथ एक निकट-संबंध इंटरफ़ेस पेश किया गया है। यह न केवल फ़ाइल विशेषताओं और I/O ऑपरेशनों पर बारीकी से नियंत्रण प्रदान करता है, बल्कि सावधान रहे बिना प्रोग्रामर्स के लिए पिटफॉल्स भी प्रदान करता है, जैसे कि संसाधनों का मैन्युअल रूप से प्रबंधन (यानी, हमेशा फ़ाइलों को बंद करना) और बफ़रिंग मुद्दे।

जबकि C में बुनियादी फ़ाइल I/O फ़ंक्शन्स शक्तिशाली हैं और कई कार्यों के लिए पर्याप्त हैं, वे आधुनिक भाषाओं द्वारा प्रदान की गई आसानी और उच्च-स्तरीय अमूर्तिकरण से कमी हैं। Python जैसी भाषाएँ मेमोरी प्रबंधन और फ़ाइल बंद करने को स्वचालित करती हैं (उदाहरण के लिए `with` स्टेटमेंट्स का उपयोग करती हैं), जिससे बूटस्ट्रैप कोड को काफी कम किया जा सकता है और संसाधन लीक्स का जोखिम कम हो जाता है। जटिल फ़ाइल मैनिपुलेशन या उच्च-स्तरीय अमूर्तिकरणों (जैसे फ़ाइल लॉक्स, असमकालिक I/O, या फ़ाइल सिस्टम इवेंट्स की निगरानी) की आवश्यकता वाले अनुप्रयोगों के लिए, इन सुविधाओं की पेशकश करने वाले लाइब्रेरीज़ की तलाश करना या ऐसी संरचनाओं का स्वाभाविक रूप से समर्थन करने वाली भाषा चुनना बेहतर हो सकता है।

फिर भी, C में फ़ाइल I/O को समझना अमूल्य है, जो उच्च-स्तरीय भाषाओं द्वारा इन सुविधाओं को कैसे लागू किया जाता है, इसकी अंतर्दृष्टि प्रदान करता है और जब प्रदर्शन और नियंत्रण सर्वोपरि होते हैं, तब कुशल, निम्न-स्तरीय कोड लिखने के उपकरण प्रदान करता है।
