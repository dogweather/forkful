---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:59:32.999048-07:00
description: "C \u092E\u0947\u0902 \u0924\u094D\u0930\u0941\u091F\u093F\u092F\u094B\
  \u0902 \u0915\u094B \u0938\u0902\u092D\u093E\u0932\u0928\u093E \u0907\u0938\u092E\
  \u0947\u0902 \u0905\u0928\u093F\u092F\u092E\u093F\u0924 \u0938\u094D\u0925\u093F\
  \u0924\u093F\u092F\u094B\u0902 \u0915\u093E \u092A\u0924\u093E \u0932\u0917\u093E\
  \u0928\u0947 \u0914\u0930 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E\
  \ \u0928\u093F\u0937\u094D\u092A\u093E\u0926\u0928 \u0915\u0947 \u0926\u094C\u0930\
  \u093E\u0928 \u0909\u0924\u094D\u092A\u0928\u094D\u0928 \u0939\u094B\u0928\u0947\
  \ \u0935\u093E\u0932\u0940 \u092A\u094D\u0930\u0924\u093F\u0915\u094D\u0930\u093F\
  \u092F\u093E\u0913\u0902 \u0938\u0947 \u0936\u093E\u092E\u093F\u0932 \u0939\u0948\
  \u0964 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E\u0930\u094D\u0938\u2026"
lastmod: '2024-02-25T18:49:50.360017-07:00'
model: gpt-4-0125-preview
summary: "C \u092E\u0947\u0902 \u0924\u094D\u0930\u0941\u091F\u093F\u092F\u094B\u0902\
  \ \u0915\u094B \u0938\u0902\u092D\u093E\u0932\u0928\u093E \u0907\u0938\u092E\u0947\
  \u0902 \u0905\u0928\u093F\u092F\u092E\u093F\u0924 \u0938\u094D\u0925\u093F\u0924\
  \u093F\u092F\u094B\u0902 \u0915\u093E \u092A\u0924\u093E \u0932\u0917\u093E\u0928\
  \u0947 \u0914\u0930 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E \u0928\
  \u093F\u0937\u094D\u092A\u093E\u0926\u0928 \u0915\u0947 \u0926\u094C\u0930\u093E\
  \u0928 \u0909\u0924\u094D\u092A\u0928\u094D\u0928 \u0939\u094B\u0928\u0947 \u0935\
  \u093E\u0932\u0940 \u092A\u094D\u0930\u0924\u093F\u0915\u094D\u0930\u093F\u092F\u093E\
  \u0913\u0902 \u0938\u0947 \u0936\u093E\u092E\u093F\u0932 \u0939\u0948\u0964 \u092A\
  \u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E\u0930\u094D\u0938\u2026"
title: "\u0924\u094D\u0930\u0941\u091F\u093F\u092F\u094B\u0902 \u0915\u093E \u0938\
  \u092E\u093E\u0927\u093E\u0928"
---

{{< edit_this_page >}}

## क्या और क्यों?

C में त्रुटियों को संभालना इसमें अनियमित स्थितियों का पता लगाने और प्रोग्राम निष्पादन के दौरान उत्पन्न होने वाली प्रतिक्रियाओं से शामिल है। प्रोग्रामर्स इसे त्रुटियों, क्रैशों, और अप्रत्याशित व्यवहार को रोकने के लिए करते हैं, यह सुनिश्चित करते हुए कि सॉफ्टवेयर विभिन्न परिस्थितियों के तहत विश्वसनीय और कुशलतापूर्वक काम करे।

## कैसे:

C में कुछ अन्य भाषाओं की तरह अपवादों के लिए निर्मित समर्थन नहीं है। इसके बजाय, यह कुछ पारंपरिक त्रुटि-संभालने की रणनीतियों पर निर्भर करता है, जैसे कि फ़ंक्शन से विशेष मूल्यों को लौटाना और `errno` जैसे वैश्विक चर को सेट करना।

**विशेष मूल्यों को लौटाना**

फ़ंक्शन एक विशिष्ट मूल्य लौटाकर त्रुटियों का संकेत दे सकते हैं जो मान्य परिणाम होना असंभाव्य है। यहाँ इन अवधारों से एक उदाहरण है:

```c
#include <stdio.h>

int inverse(int number, double *result) {
    if (number == 0) {
        return -1; // त्रुटि का मामला
    } else {
        *result = 1.0 / number;
        return 0; // सफलता
    }
}

int main() {
    double result;
    if (inverse(0, &result) < 0) {
        printf("Error: शून्य से विभाजन.\n");
    } else {
        printf("उलटा है: %f\n", result);
    }
    
    return 0;
}
```

**आउटपुट:**
```
Error: शून्य से विभाजन.
```

**`errno` की जाँच करना**

पुस्तकालय फ़ंक्शन के लिए, विशेष रूप से वे जो सिस्टम या OS (जैसे फाइल I/O) के साथ इंटरैक्ट करते हैं, `errno` एक त्रुटि होने पर सेट होता है। इसे उपयोग करने के लिए, `errno.h` को शामिल करें और एक संदिग्ध विफलता के बाद `errno` की जाँच करें:

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        printf("Error opening file: %s\n", strerror(errno));
    }
    
    return 0;
}
```

**आउटपुट:**
```
Error opening file: No such file or directory
```

## गहराई में

ऐतिहासिक रूप से, C प्रोग्रामिंग भाषा की सादगीपूर्ण डिजाइन ने एक निर्मित अपवाद संभालने की तंत्र को बाहर रखा है, जो इसकी निम्न-स्तर, सिस्टम प्रोग्रामिंग की उत्पत्ति को दर्शाती है जहाँ अधिकतम प्रदर्शन और कंट्रोल क्रिटिकल हैं। इसके बजाय, C ने एक अधिक मैनुअल त्रुटि संभालने का दृष्टिकोण अपनाया है जो इसके दर्शन के अनुकूल है, जिसमें प्रोग्रामर्स को यथासंभव अधिक नियंत्रण देना है, भले ही यह सुविधा की लागत पर हो।

जबकि यह दृष्टिकोण C के डिजाइन लक्ष्यों के साथ अच्छी तरह से मेल खाता है, यह वर्बोस त्रुटि-जांच कोड और चूकी हुई त्रुटि जांचों की संभावना को भी जन्म दे सकता है, जिसे आधुनिक भाषाओं में संरचित अपवाद संभालने की तंत्र के साथ संबोधित किया जाता है। उदाहरण के लिए, जावा या C# जैसी भाषाओं में अपवाद केंद्रीय त्रुटि प्रक्रिया की अनुमति देते हैं, कोड को साफ करते हैं और त्रुटि प्रबंधन को अधिक सरल बनाते हैं। हालांकि, अपवाद अपने ओवरहेड और जटिलता को पेश करते हैं, जो सिस्टम-लेवल प्रोग्रामिंग के लिए आदर्श नहीं हो सकती है जहां C चमकता है।

इसके कठोरता के बावजूद, C में यह मैनुअल त्रुटि संभालना कई अन्य भाषाओं के त्रुटि प्रबंधन के डिजाइन को प्रभावित किया है, जिसमें त्रुटि स्थितियों की स्पष्टता अधिक पूर्वानुमानीत और डीबग करने योग्य कोड की ओर ले जाती है। महत्वपूर्ण सिस्टमों के लिए, जहां विफलताओं को सुग्राह्य रूप से प्रबंधित किया जाना चाहिए, C की त्रुटि संभालने की परंपरा—आधुनिक सर्वोत्तम प्रथाओं जैसे कि त्रुटि संभालने की पुस्तकालयों और सम्मेलनों के साथ संयोजित—मजबूतता और विश्वसनीयता सुनिश्चित करती है।
