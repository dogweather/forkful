---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:11:41.937673-07:00
description: "\u090F\u0915 \u0907\u0902\u091F\u0930\u0947\u0915\u094D\u091F\u093F\u0935\
  \ \u0936\u0947\u0932, \u091C\u093F\u0938\u0947 Read-Eval-Print Loop (REPL) \u092D\
  \u0940 \u0915\u0939\u093E \u091C\u093E\u0924\u093E \u0939\u0948, \u092A\u094D\u0930\
  \u094B\u0917\u094D\u0930\u093E\u092E\u0930\u094D\u0938 \u0915\u094B \u0905\u092D\
  \u093F\u0935\u094D\u092F\u0915\u094D\u0924\u093F\u092F\u093E\u0901 \u092F\u093E\
  \ \u0915\u094B\u0921 \u091F\u093E\u0907\u092A \u0915\u0930\u0915\u0947 \u0924\u0941\
  \u0930\u0902\u0924 \u092A\u0930\u093F\u0923\u093E\u092E \u0926\u0947\u0916\u0928\
  \u0947 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0924\u093E\
  \ \u0939\u0948,\u2026"
lastmod: '2024-03-13T22:44:53.146057-06:00'
model: gpt-4-0125-preview
summary: "\u090F\u0915 \u0907\u0902\u091F\u0930\u0947\u0915\u094D\u091F\u093F\u0935\
  \ \u0936\u0947\u0932, \u091C\u093F\u0938\u0947 Read-Eval-Print Loop (REPL) \u092D\
  \u0940 \u0915\u0939\u093E \u091C\u093E\u0924\u093E \u0939\u0948, \u092A\u094D\u0930\
  \u094B\u0917\u094D\u0930\u093E\u092E\u0930\u094D\u0938 \u0915\u094B \u0905\u092D\
  \u093F\u0935\u094D\u092F\u0915\u094D\u0924\u093F\u092F\u093E\u0901 \u092F\u093E\
  \ \u0915\u094B\u0921 \u091F\u093E\u0907\u092A \u0915\u0930\u0915\u0947 \u0924\u0941\
  \u0930\u0902\u0924 \u092A\u0930\u093F\u0923\u093E\u092E \u0926\u0947\u0916\u0928\
  \u0947 \u0915\u0940 \u0905\u0928\u0941\u092E\u0924\u093F \u0926\u0947\u0924\u093E\
  \ \u0939\u0948,\u2026"
title: "\u0907\u0902\u091F\u0930\u0948\u0915\u094D\u091F\u093F\u0935 \u0936\u0947\u0932\
  \ (REPL) \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0928\u093E"
---

{{< edit_this_page >}}

## क्या और क्यों?

एक इंटरेक्टिव शेल, जिसे Read-Eval-Print Loop (REPL) भी कहा जाता है, प्रोग्रामर्स को अभिव्यक्तियाँ या कोड टाइप करके तुरंत परिणाम देखने की अनुमति देता है, सीखने और डिबगिंग प्रक्रियाओं को बढ़ावा देता है। बावजूद इसके कि C पारंपरिक रूप से REPL वातावरणों का समर्थन स्वाभाविक रूप से नहीं करता, आधुनिक उपकरण इस अंतर को पाटते हैं, C प्रोग्रामों का गतिशील पता लगाने की पेशकश करते हैं।

## कैसे:

C REPL के साथ संलग्न होने के लिए, आपको पायथन या जावास्क्रिप्ट जैसी भाषाओं की तरह सीधा मार्ग नहीं मिल सकता है। हालाँकि, जैसे उपकरण `Cling`, जो क्लैंग और LLVM प्रौद्योगिकी पर आधारित C/C++ इंटरप्रीटर है, यह संभव बनाते हैं। यहाँ शुरू करने का तरीका है:

1. **Cling की स्थापना**: आपके OS के आधार पर, आपको अपने पैकेज मैनेजर में Cling मिल सकता है या स्रोत से बनाने की आवश्यकता हो सकती है। उदाहरण के लिए, उबंटू पर, यह `sudo apt-get install cling` के रूप में सरल हो सकता है।

2. **Cling लॉन्च करना**: अपना टर्मिनल खोलें और इंटरेक्टिव शेल शुरू करने के लिए `cling` टाइप करें।

```bash
$ cling
```

3. **कोड लेखन**: अब आप शेल में सीधे C कोड टाइप कर सकते हैं और तत्काल परिणाम देख सकते हैं। यहाँ एक सरल उदाहरण है:

```c
[cling]$ #include <stdio.h>
[cling]$ printf("Hello, REPL world!\n");
Hello, REPL world!
```

4. **वैरिएबल्स और ऑपरेशन्स के साथ नमूना**: वैरिएबल्स के साथ प्रयोग करें और तत्काल प्रतिक्रिया देखें।

```c
[cling]$ int a = 5;
[cling]$ int b = 3;
[cling]$ printf("%d + %d = %d\n", a, b, a+b);
5 + 3 = 8
```

5. **लाइब्रेरीज को शामिल करना**: Cling आपको ऑन-द-फ्लाई लाइब्रेरीज को शामिल करने की अनुमति देता है, इस प्रकार C कार्यक्षमताओं की व्यापक रेंज को सक्षम करता है।

```c
[cling]$ #include <math.h>
[cling]$ printf("Square root of %f is %f\n", 4.0, sqrt(4.0));
वर्गमूल का 4.000000 है 2.000000
```

## गहराई से जानकारी:

REPL वातावरणों का उद्भव 1960 के दशक में लिस्प के साथ शुरू हुआ था, जिसे इंटरेक्टिव कोड मूल्यांकन का समर्थन करने के लिए डिजाइन किया गया था। हालाँकि, C की स्थिर और संकलित प्रकृति ने कोड कार्यान्वयन समायोजनों में समान तात्कालिकता को महसूस करने में चुनौतियाँ पेश कीं। Cling और अन्य C/C++ इंटरप्रीटरों का विकास स्थिर टाइप भाषाओं में गतिशील मूल्यांकन को एकीकृत करने की दिशा में महत्वपूर्ण प्रगति को चिह्नित करता है।

विशेष रूप से, Cling जैसे इंटरप्रीटर का उपयोग करना संकलित C कोड के व्यवहार को पूरी तरह से दर्शाने में सक्षम नहीं हो सकता है ऑप्टिमाइज़ेशन और कार्यान्वयन में अंतर के कारण। इसके अतिरिक्त, जबकि शैक्षिक उद्देश्यों, त्वरित प्रोटोटाइपिंग, और डिबगिंग के लिए अत्यंत मूल्यवान, C के लिए REPLs कभी-कभी धीमे हो सकते हैं और पारंपरिक कंपाइल-रन-डिबग चक्रों की तुलना में उत्पादन-स्तरीय कोड विकास के लिए कम व्यावहारिक हो सकते हैं।

सी प्रोग्रामिंग के लिए इंटरेक्टिव विकल्पों में छोटे, स्व-निहित प्रोग्राम लिखना और एकीकृत डिबगिंग उपकरणों के साथ शक्तिशाली IDE का उपयोग करना शामिल है, जो अधिक नियंत्रण और कार्यान्वयन में अंतर्दृष्टि प्रदान कर सकता है, हालाँकि कम तात्कालिकता के साथ। इन विकल्पों के बावजूद, C में REPL वातावरणों का आगमन विकास चक्रों में लचीलापन और गति के आधुनिक युग की मांगों को गले लगाते हुए भाषा की बहुमुखी प्रतिभा का एक रोमांचक विस्तार प्रस्तुत करता है।
