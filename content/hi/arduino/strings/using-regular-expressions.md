---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 19:17:24.398069-07:00
description: "\u0928\u093F\u092F\u092E\u093F\u0924 \u0905\u092D\u093F\u0935\u094D\u092F\
  \u0915\u094D\u0924\u093F\u092F\u093E\u0901 (regex) \u0935\u0930\u094D\u0923\u094B\
  \u0902 \u0915\u0947 \u0905\u0928\u0941\u0915\u094D\u0930\u092E \u0939\u094B\u0924\
  \u0947 \u0939\u0948\u0902 \u091C\u094B \u0916\u094B\u091C \u092A\u0948\u091F\u0930\
  \u094D\u0928\u094B\u0902 \u0915\u094B \u092A\u0930\u093F\u092D\u093E\u0937\u093F\
  \u0924 \u0915\u0930\u0924\u0947 \u0939\u0948\u0902, \u092E\u0941\u0916\u094D\u092F\
  \ \u0930\u0942\u092A \u0938\u0947 \u0938\u094D\u091F\u094D\u0930\u093F\u0902\u0917\
  \ \u092E\u093F\u0932\u093E\u0928 \u0914\u0930 \u092E\u0948\u0928\u093F\u092A\u0941\
  \u0932\u0947\u0936\u0928 \u0915\u0947 \u0932\u093F\u090F \u092A\u094D\u0930\u092F\
  \u0941\u0915\u094D\u0924\u2026"
lastmod: '2024-02-25T18:49:49.957731-07:00'
model: gpt-4-0125-preview
summary: "\u0928\u093F\u092F\u092E\u093F\u0924 \u0905\u092D\u093F\u0935\u094D\u092F\
  \u0915\u094D\u0924\u093F\u092F\u093E\u0901 (regex) \u0935\u0930\u094D\u0923\u094B\
  \u0902 \u0915\u0947 \u0905\u0928\u0941\u0915\u094D\u0930\u092E \u0939\u094B\u0924\
  \u0947 \u0939\u0948\u0902 \u091C\u094B \u0916\u094B\u091C \u092A\u0948\u091F\u0930\
  \u094D\u0928\u094B\u0902 \u0915\u094B \u092A\u0930\u093F\u092D\u093E\u0937\u093F\
  \u0924 \u0915\u0930\u0924\u0947 \u0939\u0948\u0902, \u092E\u0941\u0916\u094D\u092F\
  \ \u0930\u0942\u092A \u0938\u0947 \u0938\u094D\u091F\u094D\u0930\u093F\u0902\u0917\
  \ \u092E\u093F\u0932\u093E\u0928 \u0914\u0930 \u092E\u0948\u0928\u093F\u092A\u0941\
  \u0932\u0947\u0936\u0928 \u0915\u0947 \u0932\u093F\u090F \u092A\u094D\u0930\u092F\
  \u0941\u0915\u094D\u0924\u2026"
title: "\u0930\u0947\u0917\u0941\u0932\u0930 \u090F\u0915\u094D\u0938\u092A\u094D\u0930\
  \u0947\u0936\u0928\u094D\u0938 \u0915\u093E \u0909\u092A\u092F\u094B\u0917 \u0915\
  \u0930\u0928\u093E"
---

{{< edit_this_page >}}

## क्या और क्यों? 
नियमित अभिव्यक्तियाँ (regex) वर्णों के अनुक्रम होते हैं जो खोज पैटर्नों को परिभाषित करते हैं, मुख्य रूप से स्ट्रिंग मिलान और मैनिपुलेशन के लिए प्रयुक्त होते हैं। प्रोग्रामर अर्डुइनो प्रोजेक्ट्स में सीरियल इनपुट्स की पार्सिंग, यूज़र इनपुट का वैलिडेशन, या स्ट्रिंग्स से डाटा निकालने के लिए रेगेक्स का उपयोग करते हैं, डाटा प्रोसेसिंग की दक्षता और लचीलापन में सुधार करते हैं।

## कैसे:
अर्डुइनो में इसके मानक पुस्तकालय में सीधे रेगेक्स के लिए बिल्ट-इन समर्थन नहीं है। हालांकि, आप साधारण पैटर्नों के लिए बुनियादी स्ट्रिंग फंक्शन्स का उपयोग करके रेगेक्स-जैसी कार्यक्षमता प्राप्त कर सकते हैं, या अधिक जटिल जरूरतों के लिए, एक तृतीय-पक्ष पुस्तकालय जैसे `regex` को एकीकृत कर सकते हैं।

### रेगेक्स के बिना मूल स्ट्रिंग मिलान
आधारभूत जरूरतों के लिए, जैसे कि एक उपस्ट्रिंग खोजना, आप `String.indexOf()` फंक्शन का उपयोग कर सकते हैं:
```cpp
String data = "Sensor value: 12345";
int index = data.indexOf("value:");
if (index != -1) {
  String value = data.substring(index + 6).trim();
  Serial.println(value); // आउटपुट्स: 12345
}
```

### रेगेक्स के लिए एक तृतीय-पक्ष पुस्तकालय का उपयोग करना
अधिक जटिल पैटर्नों को संभालने के लिए, आप `regex` जैसी पुस्तकालय पर विचार कर सकते हैं। पुस्तकालय को स्थापित करने के बाद, आप इसका उपयोग निम्नानुसार कर सकते हैं:

1. **स्थापना**: `regex` पुस्तकालय अर्डुइनो लाइब्रेरी मैनेजर में सीधे उपलब्ध नहीं हो सकता है, इसलिए आपको इसे एक विश्वसनीय स्रोत से डाउनलोड करके और अपने अर्डुइनो पुस्तकालयों के फ़ोल्डर में जोड़ने की आवश्यकता हो सकती है।

2. **उदाहरण उपयोग**:
मानते हुए कि पुस्तकालय मानक रेगेक्स क्रियान्वयनों के समान कार्यक्षमताएं प्रदान करता है, आप इसका उपयोग निम्नानुसार कर सकते हैं:

```cpp
#include <regex.h>

void setup() {
  Serial.begin(9600);
  while (!Serial); // सीरियल के तैयार होने का इंतजार करें
  
  regex_t reg;
  const char* pattern = "[0-9]+"; // अंकों का एक अनुक्रम मिलान करता है
  regcomp(&reg, pattern, REG_EXTENDED);
  
  const char* test_str = "Sensor value: 12345";
  
  regmatch_t matches[1];
  if (regexec(&reg, test_str, 1, matches, 0) == 0) {
    // मिलान करने वाले हिस्से को निकालें और प्रिंट करें
    int start = matches[0].rm_so;
    int end = matches[0].rm_eo;
    char match[end-start+1];
    strncpy(match, test_str + start, end-start);
    match[end-start] = '\0';
    
    Serial.print("मिलान मिला: ");
    Serial.println(match); // आउटपुट्स: 12345
  } else {
    Serial.println("कोई मिलान नहीं मिला");
  }
  
  regfree(&reg); // रेगेक्स के लिए आवंटित मेमोरी को मुक्त करें
}

void loop() {
  // अपने मुख्य कोड को यहाँ रखें, बार-बार चलाने के लिए:
}
```

**नोट**: यहाँ उपयोग किया गया वाक्यविन्यास और विशिष्ट फंक्शन्स प्रदर्शनात्मक उद्देश्यों के लिए हैं और आपके द्वारा चयनित `regex` पुस्तकालय के वास्तविक कार्यान्वयन विवरणों के आधार पर भिन्न हो सकते हैं। सटीक और अद्यतन जानकारी के लिए हमेशा पुस्तकालय के दस्तावेज़ीकरण को संदर्भित करें।
