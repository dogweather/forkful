---
title:                "रेगुलर एक्सप्रेशन्स का उपयोग करना"
aliases: - /hi/clojure/using-regular-expressions.md
date:                  2024-02-03T19:17:49.471144-07:00
model:                 gpt-4-0125-preview
simple_title:         "रेगुलर एक्सप्रेशन्स का उपयोग करना"
tag:                  "Strings"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/clojure/using-regular-expressions.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?
रेगुलर एक्सप्रेशंस, पैटर्न मैचिंग और डेटा मैनिपुलेशन के लिए एक शक्तिशाली उपकरण हैं, जो इनपुट मान्यता, खोजना, और पाठ को प्रतिस्थापित करने जैसे टेक्स्ट प्रोसेसिंग कार्यों में महत्वपूर्ण हैं। प्रोग्रामर जटिल स्ट्रिंग पार्सिंग और डेटा मान्यता कार्यों को कुशलतापूर्वक और संक्षेप में संभालने के लिए उन्हें व्यापक रूप से उपयोग करते हैं।

## कैसे:
क्लोजर, लिस्प परिवार में अपनी जड़ों के प्रति सच्ची रहते हुए, जावा की रेगुलर एक्सप्रेशन क्षमताओं के साथ सहजता से इंटरफेस करने वाले कार्यों का एक समृद्ध सेट प्रदान करता है। यहाँ आप उनका उपयोग कैसे कर सकते हैं:

### मूल मिलान
यदि एक स्ट्रिंग एक पैटर्न से मेल खाती है तो जांचने के लिए `re-matches` का उपयोग करें। यदि सफल होता है तो यह पूरी मैच लौटाता है अन्यथा `nil`।

```clojure
(re-matches #"\d+" "123")  ;=> "123"
(re-matches #"\d+" "abc")  ;=> nil
```

### पैटर्नों की खोज
किसी पैटर्न की पहली उपस्थिति को खोजने के लिए, `re-find` आपके लिए जाने-माने फ़ंक्शन है:

```clojure
(re-find #"\d+" "Order 123")  ;=> "123"
```

### समूहों की कैपचरिंग
अपने पैटर्न में परेंथेसिस के साथ `re-find` का उपयोग करके समूहों को कैप्चर करें:

```clojure
(let [[_ area code] (re-find #"(1)?(\d{3})" "Phone: 123-4567")]
  (println "Area Code:" area "Code:" code))
;; आउटपुट: Area Code: nil Code: 123
```

### ग्लोबल खोज (सभी मिलान ढूँढना)
क्लोजर में कुछ भाषाओं की तरह एक निर्मित ग्लोबल खोज नहीं है। इसके बजाय, सभी मिलानों का एक आलसी अनुक्रम प्राप्त करने के लिए `re-seq` का उपयोग करें:

```clojure
(re-seq #"\d+" "id: 123, qty: 456")  ;=> ("123" "456")
```

### स्ट्रिंग्स को विभाजित करना
एक स्ट्रिंग को एक पैटर्न के आधार पर विभाजित करने के लिए, `clojure.string/split` का उपयोग करें:

```clojure
(clojure.string/split "John,Doe,30" #",")  ;=> ["John" "Doe" "30"]
```

### प्रतिस्थापन
एक स्ट्रिंग के एक हिस्से को जो एक पैटर्न से मेल खाता है, `clojure.string/replace` के साथ प्रतिस्थापित करें:

```clojure
(clojure.string/replace "2023-04-01" #"\d{4}" "YYYY")  ;=> "YYYY-04-01"
```

### तृतीय-पक्ष पुस्तकालय
हालाँकि क्लोजर का निर्मित समर्थन अधिकांश मामलों के लिए पर्याप्त है, अधिक जटिल परिदृश्यों के लिए, `clojure.spec` जैसे पुस्तकालयों का उपयोग मजबूत डेटा मान्यता और रेगेक्स-आधारित रूटिंग और इनपुट मान्यता के साथ वेब एप्लिकेशनों में रिएक्टिव DOM मैनिपुलेशन के लिए `reagent` का उपयोग करने पर विचार करें।

```clojure
;; एक ईमेल को मान्य करने के लिए clojure.spec का उपयोग करने का उदाहरण
(require '[clojure.spec.alpha :as s])
(s/def ::email (s/and string? #(re-matches #".+@.+\..+" %)))
(s/valid? ::email "test@example.com")  ;=> true
```

याद रखें, जबकि रेगुलर एक्सप्रेशंस शक्तिशाली होते हैं, वे कोड को पढ़ना और बनाए रखना कठिन बना सकते हैं। उनका उपयोग विवेकपूर्वक करें और संभव हो तो हमेशा सरल स्ट्रिंग मैनिपुलेशन फ़ंक्शन्स पर विचार करें।
