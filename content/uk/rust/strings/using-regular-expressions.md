---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 19:18:33.196694-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0411\u0456\u0431\u043B\u0456\u043E\u0442\u0435\u043A\u0430 `regex` \u0443 Rust\
  \ \u0454 \u043A\u0440\u0430\u0449\u0438\u043C \u0432\u0438\u0431\u043E\u0440\u043E\
  \u043C \u0434\u043B\u044F \u0440\u043E\u0431\u043E\u0442\u0438 \u0437 \u0440\u0435\
  \u0433\u0443\u043B\u044F\u0440\u043D\u0438\u043C\u0438 \u0432\u0438\u0440\u0430\u0437\
  \u0430\u043C\u0438. \u0429\u043E\u0431 \u0457\u0457 \u0432\u0438\u043A\u043E\u0440\
  \u0438\u0441\u0442\u0430\u0442\u0438, \u0441\u043F\u043E\u0447\u0430\u0442\u043A\
  \u0443 \u0432\u0430\u043C \u043F\u043E\u0442\u0440\u0456\u0431\u043D\u043E \u0434\
  \u043E\u0434\u0430\u0442\u0438 \u0457\u0457 \u0434\u043E \u0441\u0432\u043E\u0433\
  \u043E\u2026"
lastmod: '2024-03-13T22:44:48.920473-06:00'
model: gpt-4-0125-preview
summary: "\u0411\u0456\u0431\u043B\u0456\u043E\u0442\u0435\u043A\u0430 `regex` \u0443\
  \ Rust \u0454 \u043A\u0440\u0430\u0449\u0438\u043C \u0432\u0438\u0431\u043E\u0440\
  \u043E\u043C \u0434\u043B\u044F \u0440\u043E\u0431\u043E\u0442\u0438 \u0437 \u0440\
  \u0435\u0433\u0443\u043B\u044F\u0440\u043D\u0438\u043C\u0438 \u0432\u0438\u0440\u0430\
  \u0437\u0430\u043C\u0438."
title: "\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0440\
  \u0435\u0433\u0443\u043B\u044F\u0440\u043D\u0438\u0445 \u0432\u0438\u0440\u0430\u0437\
  \u0456\u0432"
weight: 11
---

## Як це зробити:
Бібліотека `regex` у Rust є кращим вибором для роботи з регулярними виразами. Щоб її використати, спочатку вам потрібно додати її до свого `Cargo.toml`:

```toml
[dependencies]
regex = "1"
```

Тоді ви можете почати реалізовувати функціональність regex у вашому коді на Rust. Ось як виконати деякі поширені операції:

### Пошук збігу зі шаблоном у рядку
```rust
use regex::Regex;

fn main() {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    let date = "2023-04-15";

    println!("Чи відповідає текст шаблону дати? {}", re.is_match(date));
    // Вивід: Чи відповідає текст шаблону дати? true
}
```

### Пошук та доступ до збігів
```rust
use regex::Regex;

fn main() {
    let text = "Rust 2023, C++ 2022, Python 2021";
    let re = Regex::new(r"\b(\w+)\s(\d{4})").unwrap();

    for cap in re.captures_iter(text) {
        println!("Мова: {}, Рік: {}", &cap[1], &cap[2]);
    }
    // Вивід:
    // Мова: Rust, Рік: 2023
    // Мова: C++, Рік: 2022
    // Мова: Python, Рік: 2021
}
```

### Заміна тексту
```rust
use regex::Regex;

fn main() {
    let re = Regex::new(r"\b(\w+)\s(\d{4})").unwrap();
    let text = "Rust 2023, C++ 2022, Python 2021";
    let replaced = re.replace_all(text, "$1 було оновлено в $2");

    println!("Оновлений текст: {}", replaced);
    // Вивід: Оновлений текст: Rust було оновлено в 2023, C++ було оновлено в 2022, Python було оновлено в 2021
}
```

### Розбиття тексту за допомогою Regex
```rust
use regex::Regex;

fn main() {
    let re = Regex::new(r"\W+").unwrap(); // розбити за будь-яким несловесним символом
    let text = "Rust-C++-Python-Go";

    let fields: Vec<&str> = re.split(text).collect();

    for field in fields {
        println!("Мова: {}", field);
    }
    // Вивід:
    // Мова: Rust
    // Мова: C++
    // Мова: Python
    // Мова: Go
}
```

Ці приклади надають базове керівництво для початку роботи з регулярними виразами у Rust. Коли ваши вимоги стають більш складними, крейт `regex` пропонує багатий функціонал для складного пошуку за шаблонами та завдань маніпуляції текстом.
