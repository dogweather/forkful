---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 19:32:38.229479-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0412\u0431\u0443\u0434\u043E\u0432\u0430\u043D\u0438\u0439 \u0444\u0440\u0435\
  \u0439\u043C\u0432\u043E\u0440\u043A \u0442\u0435\u0441\u0442\u0443\u0432\u0430\u043D\
  \u043D\u044F Rust \u043F\u0456\u0434\u0442\u0440\u0438\u043C\u0443\u0454 \u043C\u043E\
  \u0434\u0443\u043B\u044C\u043D\u0456, \u0456\u043D\u0442\u0435\u0433\u0440\u0430\
  \u0446\u0456\u0439\u043D\u0456 \u0442\u0430 \u0434\u043E\u043A\u0443\u043C\u0435\
  \u043D\u0442\u0430\u0446\u0456\u0439\u043D\u0456 \u0442\u0435\u0441\u0442\u0438\
  \ \u0431\u0435\u0437 \u043D\u0435\u043E\u0431\u0445\u0456\u0434\u043D\u043E\u0441\
  \u0442\u0456 \u0432 \u0437\u043E\u0432\u043D\u0456\u0448\u043D\u0456\u0445 \u0431\
  \u0456\u0431\u043B\u0456\u043E\u0442\u0435\u043A\u0430\u0445.\u2026"
lastmod: '2024-03-13T22:44:48.942398-06:00'
model: gpt-4-0125-preview
summary: "\u0412\u0431\u0443\u0434\u043E\u0432\u0430\u043D\u0438\u0439 \u0444\u0440\
  \u0435\u0439\u043C\u0432\u043E\u0440\u043A \u0442\u0435\u0441\u0442\u0443\u0432\u0430\
  \u043D\u043D\u044F Rust \u043F\u0456\u0434\u0442\u0440\u0438\u043C\u0443\u0454 \u043C\
  \u043E\u0434\u0443\u043B\u044C\u043D\u0456, \u0456\u043D\u0442\u0435\u0433\u0440\
  \u0430\u0446\u0456\u0439\u043D\u0456 \u0442\u0430 \u0434\u043E\u043A\u0443\u043C\
  \u0435\u043D\u0442\u0430\u0446\u0456\u0439\u043D\u0456 \u0442\u0435\u0441\u0442\u0438\
  \ \u0431\u0435\u0437 \u043D\u0435\u043E\u0431\u0445\u0456\u0434\u043D\u043E\u0441\
  \u0442\u0456 \u0432 \u0437\u043E\u0432\u043D\u0456\u0448\u043D\u0456\u0445 \u0431\
  \u0456\u0431\u043B\u0456\u043E\u0442\u0435\u043A\u0430\u0445."
title: "\u041F\u0438\u0441\u044C\u043C\u043E \u0442\u0435\u0441\u0442\u0456\u0432"
weight: 36
---

## Як це зробити:
Вбудований фреймворк тестування Rust підтримує модульні, інтеграційні та документаційні тести без необхідності в зовнішніх бібліотеках. Тести позначаються за допомогою `#[test]`, і будь-яка функція, позначена так, компілюється як тест.

### Написання модульного тесту:
Розмістіть модульні тести у модулі, який вони тестують, використовуючи підмодуль `tests`, позначений `#[cfg(test)]`, щоб забезпечити їх компіляцію лише під час тестування.

```rust
// lib.rs або main.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(add(2, 2), 4);
    }
}
```

Запуск тестів:
```shell
$ cargo test
```

Вивід:
```shell
   Сompiling your_package_name v0.1.0 (/path/to/your_package)
    Finished test [unoptimized + debuginfo] target(s) in 0.00 secs
     Running unittests src/lib.rs (або src/main.rs)

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

### Написання інтеграційних тестів:
Інтеграційні тести розміщуються у каталозі tests на верхньому рівні вашого проекту, поруч із `src`. Кожен файл `.rs` у `tests` компілюється як окрема самостійна крейт.

```rust
// tests/integration_test.rs
use your_package_name;

#[test]
fn it_adds_two() {
    assert_eq!(your_package_name::add(2, 2), 4);
}
```

### Тестування з популярними бібліотеками сторонніх розробників:
Для більш широких можливостей тестування бібліотека `proptest` може генерувати широкий спектр вхідних даних для тестування функцій.

Додайте `proptest` як залежність для розробки в `Cargo.toml`:

```toml
[dev-dependencies]
proptest = "1.0"
```

Використовуйте `proptest` для запуску одного і того ж тесту з багатьма автоматично генерованими вхідними даними:

```rust
// всередині tests/integration_test.rs або модуля #[cfg(test)]

use proptest::prelude::*;

proptest! {
    #[test]
    fn doesnt_crash(a: i32, b:i32) {
        your_package_name::add(a, b);
    }
}
```

Це перевіряє, що `add` не завершується з панікою для широкого діапазону вхідних даних `i32`.
