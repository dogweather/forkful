---
date: 2024-01-26 01:08:35.903604-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u043D\u0430\u043B\u0430\u0448\u0442\
  \u0443\u0454\u043C\u043E \u0431\u0430\u0437\u043E\u0432\u0438\u0439 \u0441\u0446\
  \u0435\u043D\u0430\u0440\u0456\u0439 \u043B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\
  \u044F \u0432 Rust \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u043E\
  \u044E \u043A\u0440\u0435\u0439\u0442\u0443 `log`, \u044F\u043A\u0438\u0439 \u043D\
  \u0430\u0434\u0430\u0454 \u0444\u0430\u0441\u0430\u0434 \u0434\u043B\u044F \u043B\
  \u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F, \u0442\u0430 `env_logger`, \u0440\
  \u0435\u0430\u043B\u0456\u0437\u0430\u0446\u0456\u044E\u2026"
lastmod: '2024-03-13T22:44:48.947439-06:00'
model: gpt-4-1106-preview
summary: "\u0414\u0430\u0432\u0430\u0439\u0442\u0435 \u043D\u0430\u043B\u0430\u0448\
  \u0442\u0443\u0454\u043C\u043E \u0431\u0430\u0437\u043E\u0432\u0438\u0439 \u0441\
  \u0446\u0435\u043D\u0430\u0440\u0456\u0439 \u043B\u043E\u0433\u0443\u0432\u0430\u043D\
  \u043D\u044F \u0432 Rust \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\
  \u043E\u044E \u043A\u0440\u0435\u0439\u0442\u0443 `log`, \u044F\u043A\u0438\u0439\
  \ \u043D\u0430\u0434\u0430\u0454 \u0444\u0430\u0441\u0430\u0434 \u0434\u043B\u044F\
  \ \u043B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F, \u0442\u0430 `env_logger`,\
  \ \u0440\u0435\u0430\u043B\u0456\u0437\u0430\u0446\u0456\u044E \u043B\u043E\u0433\
  \u0443\u0432\u0430\u043D\u043D\u044F \u0434\u043B\u044F \u043A\u0440\u0435\u0439\
  \u0442\u0443 `log`."
title: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F"
weight: 17
---

## Як це зробити:
Давайте налаштуємо базовий сценарій логування в Rust за допомогою крейту `log`, який надає фасад для логування, та `env_logger`, реалізацію логування для крейту `log`. Спершу додайте їх до вашого Cargo.toml:

```toml
[dependencies]
log = "0.4.14"
env_logger = "0.9.0"
```

Тепер налаштуйте та ініціалізуйте логер у вашому `main.rs`:

```rust
use log::{info, warn};

fn main() {
    env_logger::init();

    info!("Це повідомлення інформаційного типу.");
    warn!("Це повідомлення із попередженням.");
}
```

Запустіть ваш додаток за допомогою `RUST_LOG=info cargo run`, і ви побачите вивід:

```
INFO: Це повідомлення інформаційного типу.
WARN: Це повідомлення із попередженням.
```

Поекспериментуйте зі змінною оточення `RUST_LOG`, встановлюючи її до `error`, `warn`, `info`, `debug` або `trace` для керування докладністю ваших логів.

## Поглиблено
Концепція логування не є чимось новим; вона існує з ранніх днів обчислювальної техніки. До того, як логування стало поширеним у програмному забезпеченні, розробники покладалися на примітивні методи такі як оператори друку або інструменти для відлагодження для простеження виконання програми. Оскільки програми ставали складнішими, так само зросла і потреба у структурованих підходах до логування.

У Rust крейт `log` абстрагує деталі реалізації логування, дозволяючи розробникам використовувати різні бекенди для логування. Хоча `env_logger` є поширеним вибором, існують альтернативи, такі як `fern`, `slog`, або `tracing`, кожна з власним набором особливостей та опцій конфігурації.

Деякі міркування при реалізації логування включають:

1. **Рівні Логів**: Контроль детальності є ключовим. Крейт `log` в Rust визначає декілька рівнів логів: error, warn, info, debug, та trace, в порядку зменшення серйозності.

2. **Продуктивність**: Логування може впливати на продуктивність. Важливо використовувати його з розумом, пам'ятаючи про уникнення логування у шляхах критичної до продуктивності логіки або надмірно детальних логів у продакшені.

3. **Структуроване Логування**: Сучасна краща практика включає структуроване логування, де логи записуються у машинно-читабельному форматі, такому як JSON. Бібліотеки типу `slog` дозволяють здійснювати структуроване логування у Rust, яке може індексуватись та запитуватись за допомогою систем управління логами як ELK Stack або Splunk.

4. **Асинхронне Логування**: Для мінімізації впливу на основну програму, логування може виконуватися асинхронно. Це зазвичай досягається тим, що бібліотека логування записує до внутрішньої черги у пам'яті, а окремий потік обробляє чергу та записує логи до призначеного місця.

5. **Конфігурація**: Багато фреймворків логування підтримують конфігурацію через змінні оточення, файли конфігурацій та/або код. Ця гнучкість є ключовою для точного налаштування виводу в різних середовищах (розробка, стейджинг, продакшен).

## Дивіться також
- Документація крейту `log`: https://docs.rs/log/
- Документація крейту `env_logger`: https://docs.rs/env_logger/
- Сторінка логування Rust прикладами: https://doc.rust-lang.org/rust-by-example/std_misc/log.html
- Крейт `slog`, альтернативний фреймворк логування: https://github.com/slog-rs/slog
- Tracing, фреймворк для інструментування програм Rust: https://crates.io/crates/tracing
