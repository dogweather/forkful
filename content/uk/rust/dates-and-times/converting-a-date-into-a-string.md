---
date: 2024-01-20 17:37:30.523361-07:00
description: "\u042F\u043A \u0437\u0440\u043E\u0431\u0438\u0442\u0438: \u0412\u0438\
  \u0432\u0456\u0434 \u0431\u0443\u0434\u0435 \u043F\u0440\u0438\u0431\u043B\u0438\
  \u0437\u043D\u043E \u0442\u0430\u043A\u0438\u043C (\u0437\u0430\u043B\u0435\u0436\
  \u0438\u0442\u044C \u0432\u0456\u0434 \u043F\u043E\u0442\u043E\u0447\u043D\u043E\
  \u0433\u043E \u0447\u0430\u0441\u0443)."
lastmod: '2024-04-05T21:53:49.173391-06:00'
model: gpt-4-1106-preview
summary: "\u0412\u0438\u0432\u0456\u0434 \u0431\u0443\u0434\u0435 \u043F\u0440\u0438\
  \u0431\u043B\u0438\u0437\u043D\u043E \u0442\u0430\u043A\u0438\u043C (\u0437\u0430\
  \u043B\u0435\u0436\u0438\u0442\u044C \u0432\u0456\u0434 \u043F\u043E\u0442\u043E\
  \u0447\u043D\u043E\u0433\u043E \u0447\u0430\u0441\u0443)."
title: "\u041F\u0435\u0440\u0435\u0442\u0432\u043E\u0440\u0435\u043D\u043D\u044F \u0434\
  \u0430\u0442\u0438 \u0432 \u0440\u044F\u0434\u043E\u043A"
weight: 28
---

## Як зробити:
```Rust
use chrono::{DateTime, Utc, Local, NaiveDateTime};

fn main() {
    // Час в UTC
    let utc_now: DateTime<Utc> = Utc::now();
    println!("{}", utc_now.format("%Y-%m-%d %H:%M:%S").to_string());

    // Місцевий час
    let local_now: DateTime<Local> = Local::now();
    println!("{}", local_now.format("%Y-%m-%d %H:%M:%S").to_string());

    // Без конкретної часової зони
    let naive_now: NaiveDateTime = Local::now().naive_local();
    println!("{}", naive_now.format("%Y-%m-%d %H:%M:%S").to_string());
}
```
Вивід буде приблизно таким (залежить від поточного часу):
```
2023-03-15 20:45:32
2023-03-15 23:45:32
2023-03-15 23:45:32
```

## Підводні камені:
Колись програмісти писали код для перетворення дати в рядок самостійно, але це призвело до багатьох помилок. Сучасні мови, як Rust, надають бібліотеки, такі як `chrono`, для безпечного та зручного маніпулювання датами. В `chrono` є можливість використання часових зон, настройки формату й багато чого іншого.

Альтернативи вбудованим функціям перетворення дати в Rust включають використання crates, таких як `time` або `date`. Кожний має свої переваги та недоліки, вибір залежить від конкретних вимог проекту.

Внутрішня реалізація `chrono` використовує свої типи даних для зберігання дати і часу: `DateTime`, `NaiveDateTime`, і ін. Кожен з цих типів слід використовувати в залежності від ситуації, наприклад, `DateTime` для дат із часовими зонами, і `NaiveDateTime` коли зона не важлива.

## Дивіться також:
- [Документація chrono](https://docs.rs/chrono/)
- [Стандартна бібліотека Rust: модуль time](https://doc.rust-lang.org/std/time/)
