---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:10:33.415555-07:00
description: "\u0410\u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0456 \u043C\
  \u0430\u0441\u0438\u0432\u0438, \u0432\u0456\u0434\u043E\u043C\u0456 \u044F\u043A\
  \ `std::map` \u0430\u0431\u043E `std::unordered_map` \u0443 C++, \u0437\u0430\u043F\
  \u043E\u0432\u043D\u044E\u044E\u0442\u044C \u043F\u0440\u043E\u0433\u0430\u043B\u0438\
  \u043D\u0443 \u043C\u0456\u0436 \u0456\u043D\u0434\u0435\u043A\u0441\u0430\u043C\
  \u0438 \u043C\u0430\u0441\u0438\u0432\u0456\u0432 \u0442\u0430 \u0434\u0430\u043D\
  \u0438\u043C\u0438 \u0440\u0435\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0441\
  \u0432\u0456\u0442\u0443, \u0434\u043E\u0437\u0432\u043E\u043B\u044F\u044E\u0447\
  \u0438\u2026"
lastmod: '2024-03-13T22:44:49.830615-06:00'
model: gpt-4-0125-preview
summary: "\u0410\u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0456 \u043C\
  \u0430\u0441\u0438\u0432\u0438, \u0432\u0456\u0434\u043E\u043C\u0456 \u044F\u043A\
  \ `std::map` \u0430\u0431\u043E `std::unordered_map` \u0443 C++, \u0437\u0430\u043F\
  \u043E\u0432\u043D\u044E\u044E\u0442\u044C \u043F\u0440\u043E\u0433\u0430\u043B\u0438\
  \u043D\u0443 \u043C\u0456\u0436 \u0456\u043D\u0434\u0435\u043A\u0441\u0430\u043C\
  \u0438 \u043C\u0430\u0441\u0438\u0432\u0456\u0432 \u0442\u0430 \u0434\u0430\u043D\
  \u0438\u043C\u0438 \u0440\u0435\u0430\u043B\u044C\u043D\u043E\u0433\u043E \u0441\
  \u0432\u0456\u0442\u0443, \u0434\u043E\u0437\u0432\u043E\u043B\u044F\u044E\u0447\
  \u0438 \u0432\u0430\u043C \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\
  \u0432\u0443\u0432\u0430\u0442\u0438 \u0437\u043D\u0430\u0447\u0443\u0449\u0456\
  \ \u043A\u043B\u044E\u0447\u0456."
title: "\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0430\
  \u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0438\u0445 \u043C\u0430\u0441\
  \u0438\u0432\u0456\u0432"
weight: 15
---

## Що та чому?

Асоціативні масиви, відомі як `std::map` або `std::unordered_map` у C++, заповнюють прогалину між індексами масивів та даними реального світу, дозволяючи вам використовувати значущі ключі. Вони є найкращим вибором, коли вам потрібні швидкі пошуки, вставки та видалення, використовуючи ключі, а не позиції індексів.

## Як використовувати:

У C++, асоціативні масиви стають доступними з заголовочними файлами `<map>` та `<unordered_map>`. Давайте розглянемо приклади, щоб побачити обидва на практиці.

### Використання `std::map`

`std::map` зберігає елементи відсортованими на основі ключа. Ось як почати:

```C++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> ageMap;
    
    // Вставка значень
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    
    // Доступ до значень
    std::cout << "Вік Боба: " << ageMap["Bob"] << std::endl;
    
    // Ітерація по мапі
    for(const auto &pair : ageMap) {
        std::cout << pair.first << " має " << pair.second << " років." << std::endl;
    }
    
    return 0;
}
```

### Використання `std::unordered_map`

Коли порядок не має значення, але має значення продуктивність, `std::unordered_map` буде вашим другом, забезпечуючи швидшу середню складність для вставок, пошуків та видалень.

```C++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, double> productPrice;
    
    // Вставка значень
    productPrice["milk"] = 2.99;
    productPrice["bread"] = 1.99;
    
    // Доступ до значень
    std::cout << "Ціна молока: $" << productPrice["milk"] << std::endl;
    
    // Ітерація по unordered_map
    for(const auto &pair : productPrice) {
        std::cout << pair.first << " коштує $" << pair.second << std::endl;
    }
    
    return 0;
}
```

## Поглиблений розгляд

Асоціативні масиви у C++, особливо `std::map` та `std::unordered_map`, не просто про зберігання елементів. Вони забезпечують основу для складнішого управління даними, дозволяючи виконувати такі операції, як пошук, вставка та видалення за ефективною часовою складністю (логарифмічна для `std::map` та середній випадок постійного часу для `std::unordered_map`). Ця ефективність походить від основних структур даних: збалансованого дерева для `std::map` та хеш-таблиці для `std::unordered_map`.

Історично, до того як ці структури стали частиною стандартної бібліотеки, програмісти мали імплементувати свої версії або користуватися сторонніми бібліотеками, що призводило до непослідовностей і потенційних неефективностей. Включення мап до стандартної бібліотеки C++ не лише стандартизувало їх використання, але й оптимізувало їх для процесорів різних компіляторів і платформ.

Хоча обидві є потужними, вибір між `std::map` та `std::unordered_map` залежить від конкретних умов вашого випадку. Потрібні впорядковані дані і невелика втрата продуктивності вас не лякає? Вибирайте `std::map`. Якщо вам за швидкість і порядок не важливий, `std::unordered_map`, ймовірно, буде кращим варіантом.

Однак, важливо зауважити, що при роботі зі складними структурами даних завжди є компроміси. У деяких особливих випадках інші структури даних або навіть сторонні бібліотеки можуть пропонувати кращу продуктивність або функціональність, яка підходить вашим конкретним потребам. Завжди зважуйте свої варіанти, виходячи з вимог вашого проекту.
