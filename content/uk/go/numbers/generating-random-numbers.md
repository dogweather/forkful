---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:58:12.384494-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0423 Go \u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0456 \u0447\u0438\u0441\
  \u043B\u0430 \u0433\u0435\u043D\u0435\u0440\u0443\u044E\u0442\u044C\u0441\u044F\
  \ \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u043E\u044E \u043F\u0430\
  \u043A\u0435\u0442\u0430 `math/rand` \u0434\u043B\u044F \u043F\u0441\u0435\u0432\
  \u0434\u043E\u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\
  \u0441\u0435\u043B \u0430\u0431\u043E `crypto/rand` \u0434\u043B\u044F \u043A\u0440\
  \u0438\u043F\u0442\u043E\u0433\u0440\u0430\u0444\u0456\u0447\u043D\u043E \u0441\u0442\
  \u0456\u0439\u043A\u0438\u0445\u2026"
lastmod: '2024-03-13T22:44:48.426756-06:00'
model: gpt-4-0125-preview
summary: "\u0423 Go \u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0456 \u0447\u0438\
  \u0441\u043B\u0430 \u0433\u0435\u043D\u0435\u0440\u0443\u044E\u0442\u044C\u0441\u044F\
  \ \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u043E\u044E \u043F\u0430\
  \u043A\u0435\u0442\u0430 `math/rand` \u0434\u043B\u044F \u043F\u0441\u0435\u0432\
  \u0434\u043E\u0432\u0438\u043F\u0430\u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\
  \u0441\u0435\u043B \u0430\u0431\u043E `crypto/rand` \u0434\u043B\u044F \u043A\u0440\
  \u0438\u043F\u0442\u043E\u0433\u0440\u0430\u0444\u0456\u0447\u043D\u043E \u0441\u0442\
  \u0456\u0439\u043A\u0438\u0445 \u043F\u0441\u0435\u0432\u0434\u043E\u0432\u0438\u043F\
  \u0430\u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\u0441\u0435\u043B."
title: "\u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0456\u044F \u0432\u0438\u043F\u0430\
  \u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\u0441\u0435\u043B"
weight: 12
---

## Як це зробити:
У Go випадкові числа генеруються за допомогою пакета `math/rand` для псевдовипадкових чисел або `crypto/rand` для криптографічно стійких псевдовипадкових чисел. Давайте розглянемо обидва.

### Використання `math/rand` для Псевдовипадкових Чисел
Спочатку імпортуйте пакет `math/rand` та пакет `time` для ініціалізації генератора. Ініціалізація забезпечує отримання різної послідовності чисел при кожному запуску.

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	fmt.Println("Випадкове число:", rand.Intn(100)) // Генерує число між 0 і 99
}
```

Приклад виводу: `Випадкове число: 42`

### Використання `crypto/rand` для Криптографічно Стійких Псевдовипадкових Чисел
Для додаткових застосунків, чутливих до безпеки, підходить пакет `crypto/rand`, оскільки він генерує випадкові числа, які важко передбачити, роблячи їх придатними для криптографічних операцій.

```go
package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

func main() {
	n, _ := rand.Int(rand.Reader, big.NewInt(100))
	fmt.Println("Безпечне випадкове число:", n)
}
```

Приклад виводу: `Безпечне випадкове число: 81`

## Поглиблений Аналіз
Основна відмінність між пакетами `math/rand` та `crypto/rand` у Go походить від їхнього джерела ентропії та призначених сфер застосування. `math/rand` генерує псевдовипадкові числа на основі початкової ініціалізації; тобто послідовність детермінована та може бути передбачена, якщо відома ініціалізація. Це підходить для сценаріїв, де ключовим є висока продуктивність, а не абсолютна непередбачуваність, як-от симуляції або ігри.

З іншого боку, `crypto/rand` отримує випадковість з базової операційної системи, що робить його придатним для криптографічних використань, де непередбачуваність є вирішальною. Однак, це йде за рахунок продуктивності та складності в обігу чисел, які він генерує (наприклад, з обробкою типу `*big.Int` для цілих чисел).

Історично, поняття генерації випадкових чисел у комп'ютерах завжди танцювало на межі справжнього "випадковості", з ранніми системами, що сильно покладались на детерміновані алгоритми, які імітували випадковість. Як розвивалися комп'ютери, так само еволюціонували ці алгоритми, включаючи більш витончені джерела ентропії з їхнього оточення.

Незважаючи на ці досягнення, пошук ідеальної випадковості в обчисленнях принципово парадоксальний, враховуючи детермінований характер самого комп'ютера. Це є причиною, через яку для більшості застосунків, де прогнозованість могла б бути шкідливою, криптографічно стійкі псевдовипадкові числа з джерел, подібних до `crypto/rand`, є кращим варіантом, незважаючи на їх надлишок.

По суті, підхід Go з двома окремими пакетами для генерації випадкових чисел елегантно вирішує компроміс між продуктивністю та безпекою, дозволяючи розробникам вибирати залежно від їхніх конкретних потреб.
