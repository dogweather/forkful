---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:11:43.885512-07:00
description: "\u0420\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u0456 \u0432\u0438\u0440\
  \u0430\u0437\u0438 (regex) \u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443\
  \u0432\u0430\u043D\u043D\u0456 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\
  \u0432\u0443\u044E\u0442\u044C\u0441\u044F \u0434\u043B\u044F \u043F\u043E\u0448\
  \u0443\u043A\u0443, \u0437\u0456\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u043D\
  \u044F \u0442\u0430 \u043C\u0430\u043D\u0456\u043F\u0443\u043B\u044E\u0432\u0430\
  \u043D\u043D\u044F \u0440\u044F\u0434\u043A\u0430\u043C\u0438 \u043D\u0430 \u043E\
  \u0441\u043D\u043E\u0432\u0456 \u043F\u0435\u0432\u043D\u0438\u0445 \u0448\u0430\
  \u0431\u043B\u043E\u043D\u0456\u0432. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\
  \u0456\u0441\u0442\u0438\u2026"
lastmod: '2024-03-13T22:44:48.415928-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0435\u0433\u0443\u043B\u044F\u0440\u043D\u0456 \u0432\u0438\u0440\
  \u0430\u0437\u0438 (regex) \u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443\
  \u0432\u0430\u043D\u043D\u0456 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\
  \u0432\u0443\u044E\u0442\u044C\u0441\u044F \u0434\u043B\u044F \u043F\u043E\u0448\
  \u0443\u043A\u0443, \u0437\u0456\u0441\u0442\u0430\u0432\u043B\u0435\u043D\u043D\
  \u044F \u0442\u0430 \u043C\u0430\u043D\u0456\u043F\u0443\u043B\u044E\u0432\u0430\
  \u043D\u043D\u044F \u0440\u044F\u0434\u043A\u0430\u043C\u0438 \u043D\u0430 \u043E\
  \u0441\u043D\u043E\u0432\u0456 \u043F\u0435\u0432\u043D\u0438\u0445 \u0448\u0430\
  \u0431\u043B\u043E\u043D\u0456\u0432. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\
  \u0456\u0441\u0442\u0438\u2026"
title: "\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0440\
  \u0435\u0433\u0443\u043B\u044F\u0440\u043D\u0438\u0445 \u0432\u0438\u0440\u0430\u0437\
  \u0456\u0432"
---

{{< edit_this_page >}}

## Що та Чому?

Регулярні вирази (regex) у програмуванні використовуються для пошуку, зіставлення та маніпулювання рядками на основі певних шаблонів. Програмісти використовують їх для завдань, що варіюються від простих перевірок валідності до складної обробки тексту, роблячи їх незамінними для гнучкого та ефективного оброблення тексту.

## Як користуватися:

У Go пакет `regexp` надає функціональність регулярних виразів. Ось покроковий посібник з використання:

1. **Компіляція регулярного виразу**

Спочатку скомпілюйте свій шаблон регулярного виразу за допомогою `regexp.Compile`. Це хороша практика обробляти помилки, які можуть виникнути під час компіляції.

```go
package main

import (
    "fmt"
    "regexp"
)

func main() {
    pattern := "go+"
    r, err := regexp.Compile(pattern)
    if err != nil {
        fmt.Println("Помилка компіляції regex:", err)
        return
    }
    
    fmt.Println("Regex успішно скомпільовано")
}
```

2. **Зіставлення рядків**

Перевірте, чи відповідає рядок шаблону за допомогою методу `MatchString`.

```go
matched := r.MatchString("goooooogle")
fmt.Println("Зіставлено:", matched) // Вивід: Зіставлено: true
```

3. **Пошук збігів**

Щоб знайти перший збіг у рядку, використовуйте метод `FindString`.

```go
match := r.FindString("golang gooooo")
fmt.Println("Знайдено:", match) // Вивід: Знайдено: gooooo
```

4. **Пошук усіх збігів**

Для всіх збігів, `FindAllString` бере вхідний рядок та ціле число n. Якщо n >= 0, він повертає максимум n збігів; якщо n < 0, він повертає усі збіги.

```go
matches := r.FindAllString("go gooo gooooo", -1)
fmt.Println("Всі збіги:", matches) // Вивід: Всі збіги: [go gooo gooooo]
```

5. **Заміна збігів**

Для заміни збігів на інший рядок використовуйте `ReplaceAllString`.

```go
result := r.ReplaceAllString("go gooo gooooo", "Java")
fmt.Println("Замінено:", result) // Вивід: Замінено: Java Java Java
```

## Поглиблене вивчення

Пакет `regexp`, що входить до стандартної бібліотеки Go, реалізує пошук регулярних виразів та зіставлення шаблонів, натхненне синтаксисом Perl. Під капотом, двигун регулярних виразів Go компілює шаблони до форми байт-кодів, які потім виконуються двигуном зіставлення, написаним безпосередньо на Go. Ця реалізація пропонує компроміс між швидкістю виконання на прямому апаратному рівні та безпекою та простотою використання, уникаючи пасток переповнення буфера, які часто зустрічаються у бібліотеках на базі С.

Незважаючи на свою потужність, regex у Go не завжди є оптимальним рішенням для зіставлення шаблонів, особливо при роботі з високоструктурованими даними, такими як JSON або XML. У цих випадках спеціалізовані парсери або бібліотеки, розроблені для цих форматів даних, пропонують кращу продуктивність та надійність. Тим не менш, для завдань, що включають складну обробку тексту без попередньо визначеної структури, regex залишається важливим інструментом у наборі засобів програміста, пропонуючи баланс потужності та гнучкості, якому мало що може зрівнятися.
