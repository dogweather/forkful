---
title:                "Знаходження довжини рядка"
aliases:
- /uk/go/finding-the-length-of-a-string.md
date:                  2024-02-03T17:57:15.670355-07:00
model:                 gpt-4-0125-preview
simple_title:         "Знаходження довжини рядка"
tag:                  "Strings"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/go/finding-the-length-of-a-string.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Що і чому?
Знаходження довжини рядка в Go полягає у визначенні кількості символів, які він містить. Програмісти регулярно виконують цю операцію для ефективної маніпуляції з рядками, будь то для валідації, витягу підрядків або просто для накладення обмежень на користувацькі введення.

## Як:
В Go рядки розглядаються як незмінні послідовності байтів. Ви можете знайти довжину рядка, використовуючи вбудовану функцію `len()`, яка повертає кількість байтів, а не обов'язково кількість символів. Ось як це використовувати:

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// Використання len() для знаходження довжини у байтах
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("Довжина у байтах:", byteLength) // Вивід: Довжина у байтах: 13

	// Для точного отримання кількості символів або рун в рядку
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("Довжина рун:", runeLength) // Вивід: Довжина рун: 9
}
```
Перший метод використання `len()` може не завжди давати очікуваний результат, оскільки він рахує байти. Для рядків, які містять не-ASCII символи (наприклад, "世界"), замість цього слід використовувати `RuneCountInString` з пакету `unicode/utf8` для точного підрахунку Unicode кодових пунктів.

## Поглиблений огляд
До Go 1 не було чіткої відмежування для обробки рядків як послідовностей байтів проти послідовностей символів. Після Go 1, прийняття UTF-8 як стандартної схеми кодування для рядків зажадало більш чіткого підходу. Функція `len()` чудово працює для ASCII рядків, де символи представлені в одному байті. Однак, як Go програми стали більш глобальними і потреба підтримувати безліч мов і наборів символів виросла, спрощений підхід функції `len()` показав свої обмеження.

Введення і використання `utf8.RuneCountInString()` відповідає на ці обмеження, надаючи спосіб для точного підрахунку Unicode символів (рун в термінології Go). Цей метод забезпечує, що обчислення довжини незалежне від конкретики кодування UTF-8, де символи можуть займати кілька байтів.

Альтернативний підхід для перетину та маніпулювання рядками, більш узгоджений з етосом конкурентності та ефективності Go, може полягати в тому, щоб розглядати рядки як розрізи рун. Однак, цей метод потребує кроку перетворення і не відразу вирішує всі тонкощі Unicode (напр., комбіновані символи).

Підсумовуючи, хоча `len()` підходить для виміру довжини в байтах і ефективний для ASCII тексту, `utf8.RuneCountInString()` є більш надійним вибором для глобально сумісного застосування. Тим не менш, розробникам рекомендується зрозуміти компроміси в продуктивності та використанні пам'яті, які ці вибори передбачають.
