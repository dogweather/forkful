---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:09:13.431258-07:00
description: "\u041F\u043E\u0448\u0443\u043A \u0456 \u0437\u0430\u043C\u0456\u043D\
  \u0430 \u0442\u0435\u043A\u0441\u0442\u0443 \u0432 C \u043F\u043E\u043B\u044F\u0433\
  \u0430\u0454 \u0443 \u0432\u0438\u044F\u0432\u043B\u0435\u043D\u043D\u0456 \u043A\
  \u043E\u043D\u043A\u0440\u0435\u0442\u043D\u0438\u0445 \u043F\u0456\u0434\u0441\u0442\
  \u0440\u043E\u043A \u0432 \u043C\u0435\u0436\u0430\u0445 \u0431\u0456\u043B\u044C\
  \u0448\u043E\u0457 \u0441\u0442\u0440\u043E\u043A\u0438 \u0439 \u0457\u0445 \u0437\
  \u0430\u043C\u0456\u043D\u0456 \u0440\u0456\u0437\u043D\u0438\u043C\u0438 \u043F\
  \u0456\u0434\u0441\u0442\u0440\u043E\u043A\u0430\u043C\u0438. \u041F\u0440\u043E\
  \u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0432\u0438\u043A\u043E\u043D\u0443\
  \u044E\u0442\u044C \u0446\u0456\u2026"
lastmod: '2024-02-25T18:49:47.519557-07:00'
model: gpt-4-0125-preview
summary: "\u041F\u043E\u0448\u0443\u043A \u0456 \u0437\u0430\u043C\u0456\u043D\u0430\
  \ \u0442\u0435\u043A\u0441\u0442\u0443 \u0432 C \u043F\u043E\u043B\u044F\u0433\u0430\
  \u0454 \u0443 \u0432\u0438\u044F\u0432\u043B\u0435\u043D\u043D\u0456 \u043A\u043E\
  \u043D\u043A\u0440\u0435\u0442\u043D\u0438\u0445 \u043F\u0456\u0434\u0441\u0442\u0440\
  \u043E\u043A \u0432 \u043C\u0435\u0436\u0430\u0445 \u0431\u0456\u043B\u044C\u0448\
  \u043E\u0457 \u0441\u0442\u0440\u043E\u043A\u0438 \u0439 \u0457\u0445 \u0437\u0430\
  \u043C\u0456\u043D\u0456 \u0440\u0456\u0437\u043D\u0438\u043C\u0438 \u043F\u0456\
  \u0434\u0441\u0442\u0440\u043E\u043A\u0430\u043C\u0438. \u041F\u0440\u043E\u0433\
  \u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0432\u0438\u043A\u043E\u043D\u0443\u044E\
  \u0442\u044C \u0446\u0456\u2026"
title: "\u041F\u043E\u0448\u0443\u043A \u0442\u0430 \u0437\u0430\u043C\u0456\u043D\
  \u0430 \u0442\u0435\u043A\u0441\u0442\u0443"
---

{{< edit_this_page >}}

## Що і чому?

Пошук і заміна тексту в C полягає у виявленні конкретних підстрок в межах більшої строки й їх заміні різними підстроками. Програмісти виконують ці операції для маніпулювання текстовими даними - завдання варіюються від санітації даних і форматування до динамічного генерування вмісту.

## Як це зробити:

C не включає вбудованих функцій для безпосереднього пошуку та заміни в строках. Однак, це можна реалізувати, поєднавши різноманітні функції обробки строк, доступні у бібліотеці `<string.h>`, разом з деякою користувацькою логікою. Нижче наведено базовий приклад того, як знайти підстроку всередині строки та замінити її. Для спрощення цей приклад припускає достатній розмір буфера і не обробляє питання розподілу пам'яті, які ви повинні враховувати в продакшн-коді.

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void replaceSubstring(char *source, char *sub, char *new_sub) {
    char buffer[1024];
    char *insert_point = &buffer[0];
    const char *tmp = source;
    size_t len_sub = strlen(sub), len_new_sub = strlen(new_sub);
    size_t len_up_to_match;

    while ((tmp = strstr(tmp, sub))) {
        // Розрахунок довжини до збігу
        len_up_to_match = tmp - source;
        
        // Копіювання частини перед збігом
        memcpy(insert_point, source, len_up_to_match);
        insert_point += len_up_to_match;
        
        // Копіювання нової підстроки
        memcpy(insert_point, new_sub, len_new_sub);
        insert_point += len_new_sub;
        
        // Переміщення за збіг у вихідній строці
        tmp += len_sub;
        source = tmp;
    }
    
    // Копіювання будь-якої залишкової частини вихідної строки
    strcpy(insert_point, source);
    
    // Вивід зміненої строки
    printf("Змінений рядок: %s\n", buffer);
}

int main() {
    char sourceStr[] = "Hello, this is a test. This test is simple.";
    char sub[] = "test";
    char newSub[] = "sample";
    
    replaceSubstring(sourceStr, sub, newSub);
    
    return 0;
}
```

Приклад виводу:
```
Змінений рядок: Hello, this is a sample. This sample is simple.
```

Цей код демонструє простий підхід до пошуку всіх випадків підстроки (`sub`) у вихідній строці та їх заміну на іншу підстроку (`newSub`), використовуючи функцію `strstr` для знаходження початкової точки кожного збігу. Це дуже базовий приклад, який не обробляє складні сценарії, такі як перекривання підстрок.

## Поглиблений аналіз

Підхід, використаний у розділі "Як це зробити", є фундаментальним, ілюструючи спосіб досягнення пошуку тексту та його заміни в C без сторонніх бібліотек. Історично, через наголос C на низькорівневе управління пам'яттю та продуктивність, його стандартна бібліотека не включає високорівневі функціональності маніпуляцій з рядками, які можна знайти в таких мовах, як Python або JavaScript. Програмісти мають вручну управляти пам'яттю та поєднувати різні операції з рядками для досягнення бажаних результатів, що збільшує складність, але пропонує більше контролю і ефективності.

Важливо відзначити, що цей ручний підхід може бути схильним до помилок, особливо при управлінні розподілами пам'яті та розмірами буферів. Неправильне оброблення може призвести до переповнення буферів і пошкодження пам'яті, роблячи код вразливим до безпекових ризиків.

У багатьох практичних сценаріях, особливо тих, що вимагають складної обробки тексту, часто варто розглянути інтеграцію сторонніх бібліотек, таких як PCRE (Perl Compatible Regular Expressions) для пошуку та заміни на основі регулярних виразів, що може спростити код і зменшити потенціал помилок. Крім того, сучасні стандарти та компілятори C все частіше пропонують вбудовані функції та безпечніші альтернативи для маніпуляції рядками, маючи на меті уникнення загальних пасток, спостережуваних у старих кодових базах C. Однак фундаментальне розуміння ручної обробки тексту залишається цінним навиком у наборі інструментів програміста, особливо для оптимізації додатків, критичних до продуктивності.
