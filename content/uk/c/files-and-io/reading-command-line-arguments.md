---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:06:49.803296-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0423 C \u0444\u0443\u043D\u043A\u0446\u0456\u044E `main` \u043C\u043E\u0436\u043D\
  \u0430 \u0441\u043F\u0440\u043E\u0435\u043A\u0442\u0443\u0432\u0430\u0442\u0438\
  \ \u0442\u0430\u043A, \u0449\u043E\u0431 \u0432\u043E\u043D\u0430 \u043F\u0440\u0438\
  \u0439\u043C\u0430\u043B\u0430 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0438\
  \ \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u043E\u0433\u043E \u0440\u044F\u0434\
  \u043A\u0430 \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u043E\u044E\
  \ \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0456\u0432 `int argc` \u0442\
  \u0430 `char\u2026"
lastmod: '2024-03-13T22:44:50.175926-06:00'
model: gpt-4-0125-preview
summary: "\u0423 C \u0444\u0443\u043D\u043A\u0446\u0456\u044E `main` \u043C\u043E\u0436\
  \u043D\u0430 \u0441\u043F\u0440\u043E\u0435\u043A\u0442\u0443\u0432\u0430\u0442\u0438\
  \ \u0442\u0430\u043A, \u0449\u043E\u0431 \u0432\u043E\u043D\u0430 \u043F\u0440\u0438\
  \u0439\u043C\u0430\u043B\u0430 \u0430\u0440\u0433\u0443\u043C\u0435\u043D\u0442\u0438\
  \ \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u043E\u0433\u043E \u0440\u044F\u0434\
  \u043A\u0430 \u0437\u0430 \u0434\u043E\u043F\u043E\u043C\u043E\u0433\u043E\u044E\
  \ \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0456\u0432 `int argc` \u0442\
  \u0430 `char *argv[]`."
title: "\u0427\u0438\u0442\u0430\u043D\u043D\u044F \u0430\u0440\u0433\u0443\u043C\u0435\
  \u043D\u0442\u0456\u0432 \u043A\u043E\u043C\u0430\u043D\u0434\u043D\u043E\u0433\u043E\
  \ \u0440\u044F\u0434\u043A\u0430"
weight: 23
---

## Як це зробити:
У C функцію `main` можна спроектувати так, щоб вона приймала аргументи командного рядка за допомогою параметрів `int argc` та `char *argv[]`. Тут `argc` вказує кількість переданих аргументів, а `argv` - це масив вказівників на символи, що вказують усі аргументи. Ось швидкий приклад для ілюстрації:

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("Program Name: %s\n", argv[0]);
    printf("Кількість аргументів: %d\n", argc - 1);
    for (int i = 1; i < argc; i++) {
        printf("Аргумент %d: %s\n", i, argv[i]);
    }
    return 0;
}
```

Використовуючи код вище, якщо програму виконано як `./programName -a example`, вихід буде:

```
Назва програми: ./programName
Кількість аргументів: 2
Аргумент 1: -a
Аргумент 2: example
```

Це демонструє, як можна розібрати та використовувати аргументи командного рядка у програмі на C.

## Поглиблений аналіз
Конвенція передачі аргументів програмам сягає корінням найраніших днів Unix. У цьому традиційному підході, `argc` та `argv` забезпечують простий, але потужний інтерфейс для взаємодії з командним рядком, олицетворюючи філософію Unix про маленькі, модульні утиліти, які працюють разом. Хоча сучасні мови часто вводять більш складні бібліотеки або фреймворки для розбору аргументів командного рядка, прямота методу C пропонує неперевершену прозорість та контроль.

У недавніх розробках, бібліотеки, такі як `getopt` у системах POSIX, еволюціонували, щоб підтримати більш складні потреби в розборі, як-от обробка довгих імен опцій або значень за замовчуванням для відсутніх аргументів. Однак, базовий механізм `argc` та `argv` залишається важливим для розуміння, як програми взаємодіють зі своїм середовищем виконання на C.

Критики можуть стверджувати, що робота з `argc` та `argv` безпосередньо може бути схильною до помилок, наполягаючи на використанні більш високорівневих абстракцій. Проте, для тих, хто прагне оволодіти тонкощами C та оцінити нюанси його низькорівневої роботи, оволодіння розбором аргументів командного рядка є обрядом ініціації. Це поєднання історичної методології та практичної користі уособлює багато з того, що зберігає тривалу привабливість C у системному програмуванні та розробці програмного забезпечення.
