---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:14:25.715876-07:00
description: "YAML, \u0449\u043E \u043E\u0437\u043D\u0430\u0447\u0430\u0454 \"YAML\
  \ Ain't Markup Language\" (YAML \u2013 \u0446\u0435 \u043D\u0435 \u043C\u043E\u0432\
  \u0430 \u0440\u043E\u0437\u043C\u0456\u0442\u043A\u0438), \u044F\u0432\u043B\u044F\
  \u0454 \u0441\u043E\u0431\u043E\u044E \u043B\u0435\u0433\u043A\u043E \u0447\u0438\
  \u0442\u0430\u0431\u0435\u043B\u044C\u043D\u0438\u0439 \u0441\u0442\u0430\u043D\u0434\
  \u0430\u0440\u0442 \u0441\u0435\u0440\u0456\u0430\u043B\u0456\u0437\u0430\u0446\u0456\
  \u0457 \u0434\u0430\u043D\u0438\u0445, \u044F\u043A\u0438\u0439 \u043C\u043E\u0436\
  \u043D\u0430\u2026"
lastmod: 2024-02-19 22:05:09.268574
model: gpt-4-0125-preview
summary: "YAML, \u0449\u043E \u043E\u0437\u043D\u0430\u0447\u0430\u0454 \"YAML Ain't\
  \ Markup Language\" (YAML \u2013 \u0446\u0435 \u043D\u0435 \u043C\u043E\u0432\u0430\
  \ \u0440\u043E\u0437\u043C\u0456\u0442\u043A\u0438), \u044F\u0432\u043B\u044F\u0454\
  \ \u0441\u043E\u0431\u043E\u044E \u043B\u0435\u0433\u043A\u043E \u0447\u0438\u0442\
  \u0430\u0431\u0435\u043B\u044C\u043D\u0438\u0439 \u0441\u0442\u0430\u043D\u0434\u0430\
  \u0440\u0442 \u0441\u0435\u0440\u0456\u0430\u043B\u0456\u0437\u0430\u0446\u0456\u0457\
  \ \u0434\u0430\u043D\u0438\u0445, \u044F\u043A\u0438\u0439 \u043C\u043E\u0436\u043D\
  \u0430\u2026"
title: "\u0420\u043E\u0431\u043E\u0442\u0430 \u0437 YAML"
---

{{< edit_this_page >}}

## Що і чому?

YAML, що означає "YAML Ain't Markup Language" (YAML – це не мова розмітки), являє собою легко читабельний стандарт серіалізації даних, який можна використовувати для різноманітних застосунків, від файлів конфігурації до зберігання даних. Програмісти часто працюють з YAML, коли їм потрібен формат, який легко читати та легко записувати, для файлів конфігурації або обміну даними між мовами та системами.

## Як це зробити:

Робота з YAML у C вимагає бібліотеки, оскільки стандартна бібліотека C не надає прямої підтримки для аналізу YAML або серіалізації. Однією з найпопулярніших бібліотек YAML для C є `libyaml`, яка пропонує інтерфейси низького та високого рівнів для аналізу та створення YAML. Нижче наведено приклад того, як проаналізувати простий YAML-файл, використовуючи `libyaml`:

**Перше**, вам потрібно встановити бібліотеку `libyaml`. Якщо ви використовуєте Unix-подібну систему, зазвичай ви можете встановити її за допомогою менеджера пакунків. Наприклад, на Ubuntu:

```bash
sudo apt-get install libyaml-dev
```

**Далі**, розглянемо простий YAML-файл під назвою `config.yaml`:

```yaml
name: John Doe
age: 29
married: false
```

**Ось** простий приклад того, як проаналізувати цей YAML-файл у C:

```c
#include <yaml.h>
#include <stdio.h>
#include <stdlib.h>

void process_yaml_file(const char *filename) {
    FILE *fh = fopen(filename, "rb");
    yaml_parser_t parser;
    yaml_event_t event;

    if (!yaml_parser_initialize(&parser))
        fputs("Не вдалося ініціалізувати парсер YAML!\n", stderr);

    if (fh == NULL)
        fputs("Не вдалося відкрити файл!\n", stderr);

    yaml_parser_set_input_file(&parser, fh);

    while (1) {
        if (!yaml_parser_parse(&parser, &event))
            break;

        if (event.type == YAML_SCALAR_EVENT) {
            printf("Значення: %s\n", event.data.scalar.value);
        }

        if (event.type == YAML_STREAM_END_EVENT)
            break;

        yaml_event_delete(&event);
    }

    yaml_parser_delete(&parser);
    fclose(fh);
}

int main() {
    process_yaml_file("config.yaml");
    return 0;
}
```

Ця проста програма відкриває YAML-файл, ініціалізує парсер YAML і читає файл, друкуючи скалярні значення (у цьому прикладі, поля нашого простого YAML). Зверніть увагу, що перевірка на помилки у цьому простому прикладі мінімальна і повинна бути більш ретельною у виробничому коді.

Запуск програми з нашим `config.yaml` виведе:

```plaintext
Значення: John Doe
Значення: 29
Значення: false
```

## Поглиблено

Вперше YAML був випущений у 2001 році та був розроблений для більшої зручності читання та зручності для людського втручання, ніж інші формати серіалізації даних, такі як XML або JSON, запозичаючи з кількох мов, таких як C, Perl та Python, для своєї концепції дизайну. Незважаючи на свої переваги в читабельності та легкості модифікації людиною, YAML може бути складним для програмного аналізу через свою залежність від відступів та широкий набір функцій, включаючи посилання та користувацькі типи.

Хоча `libyaml` надає надійний доступ на низькому рівні до аналізу та створення YAML у С, вона може бути громіздкою для простих завдань через свій многослівний API. З цих причин деякі програмісти віддають перевагу використовувати бібліотеки вищого рівня або навіть інші формати серіалізації даних, такі як JSON, при роботі в C, особливо коли пріоритетом є швидкий аналіз з мінімальними витратами коду. Однак YAML залишається популярним вибором для файлів конфігурації та ситуацій, коли людська читабельність є первинною. Альтернативи, як-от TinyYAML або вбудовування інтерпретатора вищого рівня (наприклад, вбудовування Python або Lua), можуть забезпечити більшу зручність для певних застосунків, знаходячи баланс між легкістю використання та потребами продуктивності.
