---
date: 2024-01-26 01:09:41.212371-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0423\u044F\u0432\u0456\u0442\u044C, \u0449\u043E \u0443 \u0432\u0430\u0441 \u0454\
  \ \u043A\u043E\u0434, \u044F\u043A\u0438\u0439 \u043A\u0456\u043B\u044C\u043A\u0430\
  \ \u0440\u0430\u0437\u0456\u0432 \u0432\u0438\u0432\u043E\u0434\u0438\u0442\u044C\
  \ \u043F\u0440\u0438\u0432\u0456\u0442\u0430\u043D\u043D\u044F. \u0411\u0435\u0437\
  \ \u0444\u0443\u043D\u043A\u0446\u0456\u0439 \u0446\u0435 \u0431\u0435\u0437\u043B\
  \u0430\u0434. \u0417 \u0444\u0443\u043D\u043A\u0446\u0456\u044F\u043C\u0438 \u0432\
  \u0441\u0435 \u0430\u043A\u0443\u0440\u0430\u0442\u043D\u043E."
lastmod: '2024-03-13T22:44:49.298518-06:00'
model: gpt-4-1106-preview
summary: "\u0423\u044F\u0432\u0456\u0442\u044C, \u0449\u043E \u0443 \u0432\u0430\u0441\
  \ \u0454 \u043A\u043E\u0434, \u044F\u043A\u0438\u0439 \u043A\u0456\u043B\u044C\u043A\
  \u0430 \u0440\u0430\u0437\u0456\u0432 \u0432\u0438\u0432\u043E\u0434\u0438\u0442\
  \u044C \u043F\u0440\u0438\u0432\u0456\u0442\u0430\u043D\u043D\u044F."
title: "\u041E\u0440\u0433\u0430\u043D\u0456\u0437\u0430\u0446\u0456\u044F \u043A\u043E\
  \u0434\u0443 \u0432 \u0444\u0443\u043D\u043A\u0446\u0456\u0457"
weight: 18
---

## Як це зробити:
Уявіть, що у вас є код, який кілька разів виводить привітання. Без функцій це безлад. З функціями все акуратно.

```C#
// Без функцій - повторюється
Console.WriteLine("Привіт, Емі!");
Console.WriteLine("Привіт, Боб!");
Console.WriteLine("Привіт, Чарлі!");

// З функціями - чистіше
void Greet(string name) {
    Console.WriteLine($"Привіт, {name}!");
}

Greet("Емі");
Greet("Боб");
Greet("Чарлі");
```

Результат той самий, але друга версія набагато акуратніша.

## Поглиблено
Давно, у дні мови асемблера, для переходу до різних участків коду використовували команду GOTO — хаотично і важко відстежувати. Функції — це великий стрибок вперед, мов організовані шухлядки у інструментальному ящику. Альтернативи? Звичайно. Є методи, які є функціями у контексті класу. Тоді є лямбда-функції та інлайн-функції для швидких одноразових завдань.

Що стосується впровадження – маленькі, зосереджені функції – це скарб. Вони легші для тестування та налагодження. Великі функції з багатьма обов'язками можуть стати чудовиськами, заслуживши сумнівну назву "спагеті-код". Притримуйтеся одного завдання на функцію; потім будете собі вдячні.

## Дивіться також
Для більшої інформації про функції та кращі практики дивіться:

- "Чистий код" Роберта С. Мартіна: Принципи підтримки ваших функцій охайними.
- "Рефакторинг" Мартіна Фаулера: Шляхи покращення існуючого коду.
- Посібник Microsoft C# по методах: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods
