---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:10:32.600402-07:00
description: "\u0423 \u0441\u0432\u0456\u0442\u0456 Arduino \u0430\u0441\u043E\u0446\
  \u0456\u0430\u0442\u0438\u0432\u043D\u0456 \u043C\u0430\u0441\u0438\u0432\u0438\
  \ \u0434\u043E\u0437\u0432\u043E\u043B\u044F\u044E\u0442\u044C \u0437\u0456\u0441\
  \u0442\u0430\u0432\u043B\u044F\u0442\u0438 \u043A\u043B\u044E\u0447\u0456 \u0437\
  \u0456 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F\u043C\u0438, \u043F\u0440\
  \u0438\u0431\u043B\u0438\u0437\u043D\u043E \u0442\u0430\u043A \u0441\u0430\u043C\
  \u043E, \u044F\u043A \u0432\u0438 \u0431 \u0437\u0456\u0441\u0442\u0430\u0432\u043B\
  \u044F\u043B\u0438 \u0448\u043A\u0430\u0440\u043F\u0435\u0442\u043A\u0438 \u0437\
  \ \u0457\u0445\u043D\u0456\u043C\u0438 \u043F\u0430\u0440\u0430\u043C\u0438. \u0412\
  \u043E\u043D\u0438\u2026"
lastmod: '2024-03-13T22:44:49.707935-06:00'
model: gpt-4-0125-preview
summary: "\u0423 \u0441\u0432\u0456\u0442\u0456 Arduino \u0430\u0441\u043E\u0446\u0456\
  \u0430\u0442\u0438\u0432\u043D\u0456 \u043C\u0430\u0441\u0438\u0432\u0438 \u0434\
  \u043E\u0437\u0432\u043E\u043B\u044F\u044E\u0442\u044C \u0437\u0456\u0441\u0442\u0430\
  \u0432\u043B\u044F\u0442\u0438 \u043A\u043B\u044E\u0447\u0456 \u0437\u0456 \u0437\
  \u043D\u0430\u0447\u0435\u043D\u043D\u044F\u043C\u0438, \u043F\u0440\u0438\u0431\
  \u043B\u0438\u0437\u043D\u043E \u0442\u0430\u043A \u0441\u0430\u043C\u043E, \u044F\
  \u043A \u0432\u0438 \u0431 \u0437\u0456\u0441\u0442\u0430\u0432\u043B\u044F\u043B\
  \u0438 \u0448\u043A\u0430\u0440\u043F\u0435\u0442\u043A\u0438 \u0437 \u0457\u0445\
  \u043D\u0456\u043C\u0438 \u043F\u0430\u0440\u0430\u043C\u0438."
title: "\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0430\
  \u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0438\u0445 \u043C\u0430\u0441\
  \u0438\u0432\u0456\u0432"
weight: 15
---

## Що і чому?
У світі Arduino асоціативні масиви дозволяють зіставляти ключі зі значеннями, приблизно так само, як ви б зіставляли шкарпетки з їхніми парами. Вони стають в нагоді, коли вам потрібно зберігати та отримувати дані, використовуючи описові назви, роблячи ваш код чистішим та набагато зрозумілішим.

## Як це зробити:
Суворо кажучи, Arduino не має вбудованої підтримки асоціативних масивів, як це можна знайти в мовах вищого рівня. Але, не бійтесь. Ми можемо використати структури та масиви, щоб імітувати цю функціональність. Ось простий приклад створення базового "асоціативного масиву" для зберігання та доступу до температур у різних містах.

Спочатку, визначимо структуру, щоб зберігати місто (ключ) та його температуру (значення):

```cpp
struct CityTemperature {
  String city;
  float temperature;
};
```

Далі, ініціалізуємо масив об'єктів `CityTemperature`:

```cpp
CityTemperature temperatures[] = {
  {"New York", 19.5},
  {"Los Angeles", 22.0},
  {"Chicago", 17.0}
};
```

Ось як ви можете отримати доступ до температури конкретного міста та вивести її:

```cpp
void setup() {
  Serial.begin(9600);
  for(int i = 0; i < 3; i++) {
    if(temperatures[i].city == "Los Angeles") {
      Serial.print("Температура в Лос-Анджелесі: ");
      Serial.println(temperatures[i].temperature);
    }
  }
}

void loop() {
  // Тут поки що нічого немає.
}
```

Запуск цього коду дасть вам наступний результат:

```
Температура в Лос-Анджелесі: 22.0
```

## Поглиблене вивчення
Історично, мови програмування такі як C та C++ (з яких походить синтаксис Arduino) не мали вбудованих асоціативних масивів, що призводило до використання обхідних шляхів, як показано вище. Такий підхід є відносно простим, але погано масштабується при збільшенні розміру даних через його час пошуку O(n).

Мови, такі як Python, пропонують словники, а JavaScript має об'єкти для цієї цілі, обидва з яких набагато ефективніші для керування парами ключ-значення. У Arduino, коли продуктивність і ефективність стають критичними, розробники можуть вибирати більш спеціалізовані структури даних, як-от хеш-таблиці, реалізовані через бібліотеки.

Хоча Arduino нативно не підтримує асоціативні масиви, спільнота розробила бібліотеки, такі як `HashMap`, які можна додати до вашого проекту, щоб забезпечити подібну функціональність з кращою продуктивністю, ніж підхід "зроби сам". Ці бібліотеки, як правило, пропонують більш елегантні та ефективні способи керування асоціативними масивами, особливо для більш складних проектів.
