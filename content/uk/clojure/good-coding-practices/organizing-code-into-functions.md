---
date: 2024-01-26 01:09:40.871615-07:00
description: "\u042F\u043A \u0446\u0435 \u0437\u0440\u043E\u0431\u0438\u0442\u0438\
  : \u0424\u0443\u043D\u043A\u0446\u0456\u0457 \u0432 Clojure \u0432\u0438\u0437\u043D\
  \u0430\u0447\u0430\u044E\u0442\u044C\u0441\u044F \u0437\u0430 \u0434\u043E\u043F\
  \u043E\u043C\u043E\u0433\u043E\u044E `defn`, \u0437\u0430 \u044F\u043A\u0438\u043C\
  \ \u0441\u043B\u0456\u0434\u0443\u044E\u0442\u044C \u043D\u0430\u0437\u0432\u0430\
  , \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0438 \u0442\u0430 \u0442\u0456\
  \u043B\u043E \u0444\u0443\u043D\u043A\u0446\u0456\u0457. \u041E\u0441\u044C \u0448\
  \u0432\u0438\u0434\u043A\u0438\u0439 \u043F\u0440\u0438\u043A\u043B\u0430\u0434."
lastmod: '2024-03-13T22:44:48.662534-06:00'
model: gpt-4-1106-preview
summary: "\u0424\u0443\u043D\u043A\u0446\u0456\u0457 \u0432 Clojure \u0432\u0438\u0437\
  \u043D\u0430\u0447\u0430\u044E\u0442\u044C\u0441\u044F \u0437\u0430 \u0434\u043E\
  \u043F\u043E\u043C\u043E\u0433\u043E\u044E `defn`, \u0437\u0430 \u044F\u043A\u0438\
  \u043C \u0441\u043B\u0456\u0434\u0443\u044E\u0442\u044C \u043D\u0430\u0437\u0432\
  \u0430, \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u0438 \u0442\u0430 \u0442\
  \u0456\u043B\u043E \u0444\u0443\u043D\u043A\u0446\u0456\u0457."
title: "\u041E\u0440\u0433\u0430\u043D\u0456\u0437\u0430\u0446\u0456\u044F \u043A\u043E\
  \u0434\u0443 \u0432 \u0444\u0443\u043D\u043A\u0446\u0456\u0457"
weight: 18
---

## Як це зробити:
Функції в Clojure визначаються за допомогою `defn`, за яким слідують назва, параметри та тіло функції. Ось швидкий приклад.

```Clojure
(defn greet [name]
  (str "Привіт, " name "!"))

(greet "Олексій") ; => "Привіт, Олексій!"
```

Тепер скажімо, ми хочемо обчислити площу прямокутника. Замість того, щоб усе зіпсувати і змішати разом, ми розділимо його на дві функції:

```Clojure
(defn area [length width]
  (* length width))

(defn print-area [length width]
  (println "Площа становить:" (area length width)))

(print-area 3 4) ; => Площа становить: 12
```

## Поглиблений огляд
Давно розробники просто вдавили весь логічний код у єдиний блок. Це було потворно. Тоді настала ера структурованого програмування, і функції стали реальністю. В Clojure кожна функція є об'єктом першого класу — ви можете маніпулювати ними, як будь-яким іншим значенням.

Альтернативи? Деякі можуть погратись з мультиметодами чи функціями вищого порядку, але це всього лише спеції у страві функцій.

Усі деталі функцій: вони незмінні в Clojure, що робить ускладнення із побічними ефектами менш ймовірними. Вони в значній мірі спираються на рекурсію замість типових циклів, що добре поєднується з функціональною парадигмою мови.

## Дивіться також
- Власний посібник Clojure: https://clojure.org/guides/learn/functions
- Основи функціонального програмування: https://www.braveclojure.com/core-functions-in-depth/
- Розмови Річа Хіккі: https://changelog.com/posts/rich-hickeys-greatest-hits - для розуміння філософії Clojure.
