---
date: 2024-01-26 01:09:40.871615-07:00
description: "\u0420\u043E\u0437\u0431\u0438\u0442\u0442\u044F \u043A\u043E\u0434\u0443\
  \ \u043D\u0430 \u0444\u0443\u043D\u043A\u0446\u0456\u0457 \u043F\u043E\u043B\u044F\
  \u0433\u0430\u0454 \u0432 \u0443\u043F\u0430\u043A\u0443\u0432\u0430\u043D\u043D\
  \u0456 \u0431\u043B\u043E\u043A\u0456\u0432 \u043A\u043E\u0434\u0443, \u044F\u043A\
  \u0456 \u0432\u0438\u043A\u043E\u043D\u0443\u044E\u0442\u044C \u043F\u0435\u0432\
  \u043D\u0456 \u0437\u0430\u0432\u0434\u0430\u043D\u043D\u044F. \u0417\u0430\u0432\
  \u0434\u044F\u043A\u0438 \u0446\u044C\u043E\u043C\u0443 \u0432\u0430\u0448 \u043A\
  \u043E\u0434 \u0441\u0442\u0430\u0454 \u0447\u0438\u0441\u0442\u0456\u0448\u0438\
  \u043C, \u043B\u0435\u0433\u0448\u0438\u043C \u0434\u043B\u044F \u043F\u0456\u0434\
  \u0442\u0440\u0438\u043C\u043A\u0438 \u0442\u0430\u2026"
lastmod: 2024-02-19 22:05:07.738771
model: gpt-4-1106-preview
summary: "\u0420\u043E\u0437\u0431\u0438\u0442\u0442\u044F \u043A\u043E\u0434\u0443\
  \ \u043D\u0430 \u0444\u0443\u043D\u043A\u0446\u0456\u0457 \u043F\u043E\u043B\u044F\
  \u0433\u0430\u0454 \u0432 \u0443\u043F\u0430\u043A\u0443\u0432\u0430\u043D\u043D\
  \u0456 \u0431\u043B\u043E\u043A\u0456\u0432 \u043A\u043E\u0434\u0443, \u044F\u043A\
  \u0456 \u0432\u0438\u043A\u043E\u043D\u0443\u044E\u0442\u044C \u043F\u0435\u0432\
  \u043D\u0456 \u0437\u0430\u0432\u0434\u0430\u043D\u043D\u044F. \u0417\u0430\u0432\
  \u0434\u044F\u043A\u0438 \u0446\u044C\u043E\u043C\u0443 \u0432\u0430\u0448 \u043A\
  \u043E\u0434 \u0441\u0442\u0430\u0454 \u0447\u0438\u0441\u0442\u0456\u0448\u0438\
  \u043C, \u043B\u0435\u0433\u0448\u0438\u043C \u0434\u043B\u044F \u043F\u0456\u0434\
  \u0442\u0440\u0438\u043C\u043A\u0438 \u0442\u0430\u2026"
title: "\u041E\u0440\u0433\u0430\u043D\u0456\u0437\u0430\u0446\u0456\u044F \u043A\u043E\
  \u0434\u0443 \u0432 \u0444\u0443\u043D\u043A\u0446\u0456\u0457"
---

{{< edit_this_page >}}

## Що і чому?

Розбиття коду на функції полягає в упакуванні блоків коду, які виконують певні завдання. Завдяки цьому ваш код стає чистішим, легшим для підтримки та зрозумілішим для інших розробників.

## Як це зробити:

Функції в Clojure визначаються за допомогою `defn`, за яким слідують назва, параметри та тіло функції. Ось швидкий приклад.

```Clojure
(defn greet [name]
  (str "Привіт, " name "!"))

(greet "Олексій") ; => "Привіт, Олексій!"
```

Тепер скажімо, ми хочемо обчислити площу прямокутника. Замість того, щоб усе зіпсувати і змішати разом, ми розділимо його на дві функції:

```Clojure
(defn area [length width]
  (* length width))

(defn print-area [length width]
  (println "Площа становить:" (area length width)))

(print-area 3 4) ; => Площа становить: 12
```

## Поглиблений огляд

Давно розробники просто вдавили весь логічний код у єдиний блок. Це було потворно. Тоді настала ера структурованого програмування, і функції стали реальністю. В Clojure кожна функція є об'єктом першого класу — ви можете маніпулювати ними, як будь-яким іншим значенням.

Альтернативи? Деякі можуть погратись з мультиметодами чи функціями вищого порядку, але це всього лише спеції у страві функцій.

Усі деталі функцій: вони незмінні в Clojure, що робить ускладнення із побічними ефектами менш ймовірними. Вони в значній мірі спираються на рекурсію замість типових циклів, що добре поєднується з функціональною парадигмою мови.

## Дивіться також

- Власний посібник Clojure: https://clojure.org/guides/learn/functions
- Основи функціонального програмування: https://www.braveclojure.com/core-functions-in-depth/
- Розмови Річа Хіккі: https://changelog.com/posts/rich-hickeys-greatest-hits - для розуміння філософії Clojure.
