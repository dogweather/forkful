---
date: 2024-01-27 20:34:40.087045-07:00
description: "\u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0456\u044F \u0432\u0438\u043F\
  \u0430\u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\u0441\u0435\u043B \u0443\
  \ \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443\u0432\u0430\u043D\u043D\u0456\
  \ \u043F\u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u0441\u0442\u0432\u043E\u0440\
  \u0435\u043D\u043D\u0456 \u0447\u0438\u0441\u0435\u043B, \u044F\u043A\u0456 \u043D\
  \u0435 \u043C\u0430\u044E\u0442\u044C \u0436\u043E\u0434\u043D\u043E\u0433\u043E\
  \ \u043F\u0440\u043E\u0433\u043D\u043E\u0437\u043E\u0432\u0430\u043D\u043E\u0433\
  \u043E \u0432\u0456\u0437\u0435\u0440\u0443\u043D\u043A\u0443. \u041F\u0440\u043E\
  \u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0440\u043E\u0431\u043B\u044F\u0442\
  \u044C \u0446\u0435 \u0437 \u0440\u0456\u0437\u043D\u0438\u0445\u2026"
lastmod: '2024-03-11T00:14:23.066825-06:00'
model: gpt-4-0125-preview
summary: "\u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0456\u044F \u0432\u0438\u043F\
  \u0430\u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\u0441\u0435\u043B \u0443\
  \ \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443\u0432\u0430\u043D\u043D\u0456\
  \ \u043F\u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u0441\u0442\u0432\u043E\u0440\
  \u0435\u043D\u043D\u0456 \u0447\u0438\u0441\u0435\u043B, \u044F\u043A\u0456 \u043D\
  \u0435 \u043C\u0430\u044E\u0442\u044C \u0436\u043E\u0434\u043D\u043E\u0433\u043E\
  \ \u043F\u0440\u043E\u0433\u043D\u043E\u0437\u043E\u0432\u0430\u043D\u043E\u0433\
  \u043E \u0432\u0456\u0437\u0435\u0440\u0443\u043D\u043A\u0443. \u041F\u0440\u043E\
  \u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0440\u043E\u0431\u043B\u044F\u0442\
  \u044C \u0446\u0435 \u0437 \u0440\u0456\u0437\u043D\u0438\u0445\u2026"
title: "\u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0456\u044F \u0432\u0438\u043F\u0430\
  \u0434\u043A\u043E\u0432\u0438\u0445 \u0447\u0438\u0441\u0435\u043B"
---

{{< edit_this_page >}}

## Що і чому?

Генерація випадкових чисел у програмуванні полягає у створенні чисел, які не мають жодного прогнозованого візерунку. Програмісти роблять це з різних причин, у тому числі для симуляцій, тестування алгоритмів, ігор та застосунків безпеки, де непередбачуваність є ключовою для досягнення реалістичних або безпечних результатів.

## Як це зробити:

Kotlin надає простий спосіб генерації випадкових чисел через свою стандартну бібліотеку. Ось як ви можете генерувати різні типи випадкових значень:

### Генерація випадкового цілого числа

Щоб згенерувати випадкове ціле число в певному діапазоні:

```kotlin
import kotlin.random.Random

fun main() {
    val randomNumber = Random.nextInt(1, 100) // Генерує випадкове число від 1 до 99
    println(randomNumber)
}
```

### Генерація випадкового дробового числа

Аналогічно, для генерації випадкового дробового числа:

```kotlin
import kotlin.random.Random

fun main() {
    val randomDouble = Random.nextDouble(1.0, 10.0) // Генерує випадкове дробове число від 1.0 до 10.0
    println(randomDouble)
}
```

### Генерація випадкового булевого значення

Для генерації випадкового булевого значення:

```kotlin
import kotlin.random.Random

fun main() {
    val randomBoolean = Random.nextBoolean() // Випадково генерує true або false
    println(randomBoolean)
}
```

### Встановлення початкового значення для відтворюваних результатів

У випадках, коли вам потрібні відтворювані послідовності випадкових чисел (наприклад, при тестуванні), ви можете встановити початкове значення генератора випадкових чисел:

```kotlin
import kotlin.random.Random

fun main() {
    val seed = 12345L
    val random = Random(seed)
    val randomNumber = random.nextInt(1, 100)
    println(randomNumber)
}
```

## Поглиблений аналіз

Підхід стандартної бібліотеки Kotlin до генерації випадкових чисел використовує `java.util.Random`, що забезпечує поєднання простоти використання та продуктивності. Однак важливо зазначити, що ці методи генерують псевдовипадкові числа, що означає, що числа здаються випадковими, але генеруються за допомогою детермінованого процесу.

Для більшості застосунків випадковість, надана класом `Random` Kotlin, є достатньою. Однак для застосунків, чутливих до безпеки, таких як криптографія, де якість випадковості є найважливішою, слід розглянути використання `java.security.SecureRandom` замість цього. SecureRandom спеціально призначений для криптографічних операцій, забезпечуючи вищу якість випадковості, хоча з потенційним зниженням продуктивності.

Kotlin не винаходить колесо заново, але пропонує Kotlin-орієнтоване API над механізмами генерації випадкових чисел Java, роблячи його більш ідіоматичним та лаконічним для використання у проектах Kotlin. Як завжди, коли мова йде про випадковість, програмісти повинні ретельно враховувати конкретний випадок використання, щоб вибрати найбільш відповідний інструмент для роботи.
