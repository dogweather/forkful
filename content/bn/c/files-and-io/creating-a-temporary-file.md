---
changelog:
- 2024-03-17, OpenAIModel.GPT_4_TURBO, translated from English
date: 2024-03-17 17:48:01.603843-06:00
description: "C \u09AD\u09BE\u09B7\u09BE\u09AF\u09BC \u098F\u0995\u099F\u09BF \u0985\
  \u09B8\u09CD\u09A5\u09BE\u09AF\u09BC\u09C0 \u09AB\u09BE\u0987\u09B2 \u09A4\u09C8\
  \u09B0\u09BF \u0995\u09B0\u09BE \u09AE\u09BE\u09A8\u09C7 \u098F\u09AE\u09A8 \u098F\
  \u0995\u099F\u09BF \u09AB\u09BE\u0987\u09B2 \u09A4\u09C8\u09B0\u09BF \u0995\u09B0\
  \u09BE \u09AF\u09BE \u09B8\u09BE\u09AE\u09AF\u09BC\u09BF\u0995 \u09B8\u09AE\u09AF\
  \u09BC\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\
  \u09B0\u09C7\u09B0 \u0989\u09A6\u09CD\u09A6\u09C7\u09B6\u09CD\u09AF \u09B0\u09BE\
  \u0996\u09C7, \u09B8\u09BE\u09A7\u09BE\u09B0\u09A3\u09A4 \u09A1\u09BE\u099F\u09BE\
  \ \u09AA\u09CD\u09B0\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\u09BE\u0995\u09B0\u09A3\
  \ \u09AC\u09BE \u09B8\u099E\u09CD\u099A\u09AF\u09BC\u09C7\u09B0\u2026"
lastmod: '2024-03-17T18:47:44.563371-06:00'
model: gpt-4-0125-preview
summary: "C \u09AD\u09BE\u09B7\u09BE\u09AF\u09BC \u098F\u0995\u099F\u09BF \u0985\u09B8\
  \u09CD\u09A5\u09BE\u09AF\u09BC\u09C0 \u09AB\u09BE\u0987\u09B2 \u09A4\u09C8\u09B0\
  \u09BF \u0995\u09B0\u09BE \u09AE\u09BE\u09A8\u09C7 \u098F\u09AE\u09A8 \u098F\u0995\
  \u099F\u09BF \u09AB\u09BE\u0987\u09B2 \u09A4\u09C8\u09B0\u09BF \u0995\u09B0\u09BE\
  \ \u09AF\u09BE \u09B8\u09BE\u09AE\u09AF\u09BC\u09BF\u0995 \u09B8\u09AE\u09AF\u09BC\
  \u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0\
  \u09C7\u09B0 \u0989\u09A6\u09CD\u09A6\u09C7\u09B6\u09CD\u09AF \u09B0\u09BE\u0996\
  \u09C7, \u09B8\u09BE\u09A7\u09BE\u09B0\u09A3\u09A4 \u09A1\u09BE\u099F\u09BE \u09AA\
  \u09CD\u09B0\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\u09BE\u0995\u09B0\u09A3 \u09AC\u09BE\
  \ \u09B8\u099E\u09CD\u099A\u09AF\u09BC\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF \u09B8\
  \u09CD\u0995\u09CD\u09B0\u09CD\u09AF\u09BE\u099A \u09B8\u09CD\u09AA\u09C7\u09B8\
  \ \u09B9\u09BF\u09B8\u09C7\u09AC\u09C7\u0964 \u09AA\u09CD\u09B0\u09CB\u0997\u09CD\
  \u09B0\u09BE\u09AE\u09BE\u09B0\u09B0\u09BE \u098F\u099F\u09BE \u0995\u09B0\u09C7\
  \ \u09A5\u09BE\u0995\u09C7\u09A8 \u0985\u09B8\u09CD\u09A5\u09BE\u09AF\u09BC\u09C0\
  \ \u09A1\u09BE\u099F\u09BE \u09AA\u09B0\u09BF\u099A\u09BE\u09B2\u09A8\u09BE \u0995\
  \u09B0\u09A4\u09C7 \u0985\u09A8\u09CD\u09AF\u09BE\u09A8\u09CD\u09AF \u09B8\u09CD\
  \u09A5\u09BE\u09AF\u09BC\u09C0 \u09B8\u09CD\u099F\u09CB\u09B0\u09C7\u099C\u0995\u09C7\
  \ \u09AA\u09CD\u09B0\u09AD\u09BE\u09AC\u09BF\u09A4 \u09A8\u09BE \u0995\u09B0\u09C7\
  \ \u09AC\u09BE \u09A8\u09BF\u09B0\u09BE\u09AA\u09A6 \u09A1\u09BE\u099F\u09BE\u0995\
  \u09C7 \u09AC\u09CD\u09AF\u09AC\u09B9\u09BE\u09B0\u09C7\u09B0 \u09AA\u09B0\u09C7\
  \ \u09AE\u09C1\u099B\u09C7 \u09AB\u09C7\u09B2\u09BE\u09B0 \u09A8\u09BF\u09B6\u09CD\
  \u099A\u09AF\u09BC\u09A4\u09BE \u09A6\u09C7\u09AF\u09BC\u0964."
title: "\u098F\u0995\u099F\u09BF \u0985\u09B8\u09CD\u09A5\u09BE\u09AF\u09BC\u09C0\
  \ \u09AB\u09BE\u0987\u09B2 \u09A4\u09C8\u09B0\u09BF \u0995\u09B0\u09BE"
weight: 21
---

## কি এবং কেন?
C ভাষায় একটি অস্থায়ী ফাইল তৈরি করা মানে এমন একটি ফাইল তৈরি করা যা সাময়িক সময়ের জন্য ব্যবহারের উদ্দেশ্য রাখে, সাধারণত ডাটা প্রক্রিয়াকরণ বা সঞ্চয়ের জন্য স্ক্র্যাচ স্পেস হিসেবে। প্রোগ্রামাররা এটা করে থাকেন অস্থায়ী ডাটা পরিচালনা করতে অন্যান্য স্থায়ী স্টোরেজকে প্রভাবিত না করে বা নিরাপদ ডাটাকে ব্যবহারের পরে মুছে ফেলার নিশ্চয়তা দেয়।

## কিভাবে:
C প্রোগ্রামিং ভাষায় একটি অস্থায়ী ফাইল তৈরি করতে `tmpfile()` এবং `mkstemp()` এর মতো ফাংশন ব্যবহার করা যায়।

**`tmpfile()` ব্যবহার করে:** এই ফাংশন একটি অনন্য অস্থায়ী ফাইল তৈরি করে যা অটোম্যাটিকভাবে মোছা হয় যখন প্রোগ্রাম শেষ হয় বা ফাইলটি বন্ধ করা হয়।

```c
#include <stdio.h>

int main() {
    FILE *temp = tmpfile();
    if (temp == NULL) {
        perror("Failed to create temporary file");
        return 1;
    }

    // অস্থায়ী ফাইলে ডাটা লেখা
    fputs("This is a test.\n", temp);

    // লেখা ডাটা পুনরায় পড়া
    rewind(temp);
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), temp) != NULL) {
        printf("%s", buffer);
    }

    // বন্ধ করলে বা প্রোগ্রাম শেষ হলে অটোম্যাটিক মোছা হয়
    fclose(temp);

    return 0;
}
```
**নমুনা আউটপুট:**
```
This is a test.
```

**`mkstemp()` ব্যবহার করে:** অস্থায়ী ফাইলের অবস্থান এবং এর অনুমতিগুলি নিয়ন্ত্রণে অধিক নিয়ন্ত্রণ দেয়। এটি একটি টেম্প্লেট স্ট্রিং চায় যা `XXXXXX` দিয়ে শেষ হয় যা এটি একটি অনন্য ক্রম দিয়ে প্রতিস্থাপিত করে নাম দুর্ঘটনার এড়ায়।

```c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>

int main() {
    char template[] = "/tmp/mytemp-XXXXXX";
    int fd = mkstemp(template);

    if (fd == -1) {
        perror("Failed to create temporary file");
        return 1;
    }
    
    printf("Temporary file created: %s\n", template);

    // mkstemp() দিয়ে তৈরি অস্থায়ী ফাইলগুলি ম্যানুয়ালি মোছা উচিত
    unlink(template);

    close(fd);
    return 0;
}
```
**নমুনা আউটপুট:**
```
Temporary file created: /tmp/mytemp-abc123
```

## গভীর অন্বেষণ
অস্থায়ী ফাইলের ধারণা C ভাষায় অনন্য নয়, বরং অনেক প্রোগ্রামিং পরিবেশে এটি একটি সাধারণ ফাংশনালিটি, যা মূহূর্তিক ডাটা প্রক্রিয়াকরণে তার প্রয়োজনীয়তা দ্বারা সৃষ্টি হয়েছে। `tmpfile()` ফাংশন, আইএসও C মান অনুযায়ী স্ট্যান্ডার্ডাইজড, একটি অনন্য নামের সাথে একটি ফাইল তৈরি করে, যা একটি মানক ডিরেক্টরিতে থাকে, কিন্তু এর অস্তিত্ব অস্থায়ী, যা এটিকে নিরাপদ বা অস্থায়ী অপারেশনের জন্য আদর্শ করে তোলে।

`tmpfile()` এর একটি লক্ষণীয় সীমাবদ্ধতা হলো এর ডিফল্ট অস্থায়ী ডিরেক্টরির উপর নির্ভরতা, যা সব অ্যাপ্লিকেশনের জন্য উপযুক্ত নাও হতে পারে বিশেষ করে অনুমতি বা নিরাপত্তা দিক থেকে। বিপরীতে, `mkstemp()` ডিরেক্টরি নির্দিষ্ট করে এবং প্রদত্ত টেমপ্লেট স্ট্রিং পরিবর্তন করে অনন্য ফাইলনাম তৈরির সাথে নিরাপদ ফাইল তৈরি নিশ্চিত করে, ম্যানুয়াল ফাইল পরিচালনার বিনিময়ে একটি বিস্তৃত সমাধান অফার করে। 

তবে, অস্থায়ী ফাইল তৈরি করলে নিরাপত্তা সংবেদনশীলতা তৈরি হতে পারে, যেমন রেস কন্ডিশন, যদি ঠিকভাবে পরিচালনা না করা হয়। উদাহরণস্বরূপ, `tmpfile()` এবং `mkstemp()` নিরাপদ অস্থায়ী ফাইল তৈরির বিভিন্ন দিক (অটোম্যাটিক মোছার এবং নিরাপদ নাম তৈরির, যথাক্রমে) ঠিকানা করলেও, কোনটিই সর্বজনীন সমাধান নয়। ডেভেলপারদের তাদের অ্যাপ্লিকেশনের নিরাপত্তা প্রয়োজনীয়তা বিশেষ করে অস্থায়ী ফাইলগুলি দ্বারা প্রবর্তিত সম্ভাব্য ঝুঁকিগুলি বিবেচনা করে এই ফাংশনগুলি অতিরিক্ত সুরক্ষা বিধানের প্রয়োজন হতে পারে।

প্রোগ্রামিং এর বিস্তৃত পরিপ্রেক্ষিতে, মেমোরি-ম্যাপড ফাইলগুলির ব্যবহারের মত ইন-মেমরি স্টোরেজ অস্থায়ী ডাটা পরিচালনায় উন্নত পারফরমেন্স বা নিরাপত্তা অফার করতে পারে। তবে, বড় ডাটা সেট বা যখন প্রক্রিয়া-মধ্যে যোগাযোগ জড়িত থাকে তখন বাস্তব অস্থায়ী ফাইল অনেক পরিস্থিতিতে একটি অপরিহার্য টুল হিসেবে থাকে।
