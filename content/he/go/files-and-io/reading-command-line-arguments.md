---
title:                "קריאת ארגומנטים משורת הפקודה"
aliases:
- /he/go/reading-command-line-arguments.md
date:                  2024-02-03T18:07:42.259753-07:00
model:                 gpt-4-0125-preview
simple_title:         "קריאת ארגומנטים משורת הפקודה"
tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/he/go/reading-command-line-arguments.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## מה ולמה?

קריאת ארגומנטים משורת הפקודה ב-Go כוללת את חילוץ הארגומנטים שניתנו לתוכנית בזמן הפעלתה מהטרמינל או ממסוף הפקודות. מתכנתים עושים זאת כדי להתאים אישית את ביצוע התוכנית ללא שינוי בקוד, מה שהופך את היישומים לגמישים ומונעים על ידי המשתמש יותר.

## איך לעשות:

Go מספקת גישה ישירה לארגומנטים משורת הפקודה דרך החבילה `os`, באופן ספציפי באמצעות `os.Args`, מערך של מחרוזות. הנה דוגמה פשוטה להתחלה:

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // os.Args מספקת גישה לארגומנטים גולמיים משורת הפקודה
    fmt.Println("ארגומנטים משורת הפקודה:", os.Args)

    if len(os.Args) > 1 {
        // חצייה על הארגומנטים, דילוג על הראשון (שם התוכנית)
        for i, arg := range os.Args[1:] {
            fmt.Printf("ארגומנט %d: %s\n", i+1, arg)
        }
    } else {
        fmt.Println("לא סופקו ארגומנטים משורת הפקודה.")
    }
}
```

פלט לדוגמה כאשר מריצים עם `go run yourprogram.go arg1 arg2` יכול להיראות כך:

```
ארגומנטים משורת הפקודה: [/tmp/go-build123456789/b001/exe/yourprogram arg1 arg2]
ארגומנט 1: arg1
ארגומנט 2: arg2
```

זה מדפיס את כל הארגומנטים כולל שם התוכנית (לרוב באינדקס 0), ואז עובר על כל ארגומנט שניתן, ומדפיס אותם. לצורך פרסור ארגומנטים מבוקר יותר, כדאי לשקול את החבילה `flag` לפרסור אפשרויות משורת הפקודה.

## טבילה עמוקה

באופן היסטורי, גישה לארגומנטים משורת הפקודה היא מסורת כמו תכנות ב-C, שם `argc` ו-`argv[]` משמשים למטרה דומה. ב-Go, `os.Args` פשוט מאוד אך במכוון ראשוני. לתרחישים מורכבים יותר, כמו התמודדות עם דגלים או אפשרויות, Go מציעה את החבילה `flag` שמספקת יכולת פרסור עמידה בפני תוקפים. זו עשויה להיכנס כאלטרנטיבה "טובה יותר" כאשר היישום שלך דורש יותר מאשר רק ארגומנטים עמדתיים.

בניגוד לחלק משפות התסריט שמציעות פרסור מובנה של ארגומנטים משורת הפקודה למערכים המורכבים או אובייקטים, הגישה של Go דורשת ממתכנתים לטפל בפרסור בעצמם באמצעות `os.Args` לצרכים בסיסיים או להשתמש בחבילה `flag` לתרחישים מתקדמים יותר. עיצוב זה משקף את פילוסופיית Go של שמירה על שפת הליבה פשוטה תוך הצעת ספריות סטנדרטיות חזקות למשימות נפוצות. על אף שזה עשוי להציג עקומת למידה מסוימת למי שמורגל בפרסור מובנה, זה מציע גמישות רבה יותר ומעודד הבנה עמוקה יותר של טיפול בארגומנטים משורת הפקודה.
