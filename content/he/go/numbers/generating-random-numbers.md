---
title:                "גירוד מספרים אקראיים"
aliases:
- /he/go/generating-random-numbers.md
date:                  2024-02-03T17:58:48.140341-07:00
model:                 gpt-4-0125-preview
simple_title:         "גירוד מספרים אקראיים"
tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/he/go/generating-random-numbers.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## מה ולמה?

יצירת מספרים אקראיים בתכנות היא עניין של יצירת סדרה של מספרים שלא ניתן לחזות אותם בצורה מושכלת יותר מאקראיות. מתכנתים עושים זאת מספר סיבות, כולל סימולציות, משחקים, ויישומי אבטחה, שבהם חשובה הבלתי צפיות עבור פונקציונליות או סודיות.

## איך לעשות:

בשפת Go יוצרים מספרים אקראיים באמצעות החבילה `math/rand` עבור מספרים פסבדו-אקראיים או `crypto/rand` עבור מספרים פסבדו-אקראיים מאובטחים קריפטוגרפית. בואו נחקור את שניהם.

### שימוש ב-`math/rand` עבור מספרים פסבדו-אקראיים

ראשית, יבוא החבילה `math/rand` וכן את חבילת `time` כדי לזרוע את המחולל. הזריעה מבטיחה שתקבלו סדרה שונה של מספרים בכל הפעלה.

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	fmt.Println("מספר אקראי:", rand.Intn(100)) // יוצר מספר בין 0 ל-99
}
```

פלט לדוגמה: `מספר אקראי: 42`

### שימוש ב-`crypto/rand` עבור מספרים פסבדו-אקראיים מאובטחים קריפטוגרפית

עבור יישומים רגישים יותר לאבטחה, החבילה `crypto/rand` מתאימה מכיוון שהיא מייצרת מספרים אקראיים שקשה לחזות, המתאימים לפעולות קריפטוגרפיות.

```go
package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

func main() {
	n, _ := rand.Int(rand.Reader, big.NewInt(100))
	fmt.Println("מספר אקראי מאובטח:", n)
}
```

פלט לדוגמה: `מספר אקראי מאובטח: 81`

## חקירה מעמיקה

ההבדל העיקרי בין חבילות ה-`math/rand` ו-`crypto/rand` ב-Go נובע ממקור האנטרופיה שלהם ומהשימושים המיועדים שלהם. `math/rand` מייצרת מספרים פסבדו-אקראיים מבוססים על זרע התחלתי; בכך, הסדרה היא דטרמיניסטית וניתן לחזות אותה אם ידוע הזרע. זה מתאים לתרחישים שבהם ביצועים גבוהים ולא הבלתי צפיות היא הדאגה המרכזית, כמו בסימולציות או משחקים.

מאידך, `crypto/rand` מפיקה אקראיות ממערכת ההפעלה הבסיסית, מה שהופך אותה למתאימה לשימושים קריפטוגרפיים שבהם הבלתי צפיות היא קריטית. עם זאת, זה בא עם מחיר של ביצועים וסיבוכיות בניהול המספרים שהיא מייצרת (כמו התמודדות עם הטיפוס `*big.Int` למספרים שלמים).

היסטורית, הרעיון של יצירת מספרים אקראיים במחשבים תמיד רקד על הקצה של "אקראיות" אמיתית, עם מערכות מוקדמות שתלו במידה רבה באלגוריתמים דטרמיניסטיים שחיקו אקראיות. עם התפתחות המחשבים, כך גם אלו האלגוריתמים, כאשר הם כללו מקורות אנטרופיה מתוחכמים יותר מהסביבה שלהם.

למרות התקדמויות אלה, המסע לקראת אקראיות מושלמת בחישובים הוא בלתי אפשרי באופן עקרוני, בהתחשב באופי הדטרמיניסטי של המחשבים עצמם. זו הסיבה שלרוב היישומים שבהם צפיות תהיה מזיקה, מספרים פסבדו-אקראיים מאובטחים קריפטוגרפית ממקורות כמו `crypto/rand` הם האלטרנטיבה הטובה יותר, למרות המחיר שלהם.

בעצם, הגישה של Go עם שני חבילות נפרדות ליצירת מספרים אקראיים מתייחסת בחן לפשרות בין ביצועים לאבטחה, מאפשרת למפתחים לבחור בהתאם לצרכים הספציפיים שלהם.
