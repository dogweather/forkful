---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:53:47.560876-07:00
description: "\u05D4\u05E4\u05D9\u05DB\u05EA \u05DE\u05D7\u05E8\u05D5\u05D6\u05EA\
  \ \u05DC\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05E8\u05D9\u05E9\u05D9\u05D5\u05EA\
  \ \u05D1\u05E9\u05E4\u05EA C \u05DB\u05D5\u05DC\u05DC\u05EA \u05D4\u05DE\u05E8\u05D4\
  \ \u05E9\u05DC \u05D4\u05EA\u05D5 \u05D4\u05E8\u05D0\u05E9\u05D5\u05DF \u05D1\u05DB\
  \u05DC \u05DE\u05D9\u05DC\u05D4 \u05D1\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05E0\
  \u05EA\u05D5\u05E0\u05D4 \u05DC\u05D0\u05D5\u05EA \u05D2\u05D3\u05D5\u05DC\u05D4\
  , \u05D0\u05DD \u05D4\u05D5\u05D0 \u05D1\u05D0\u05D5\u05EA \u05E7\u05D8\u05E0\u05D4\
  . \u05EA\u05DB\u05E0\u05EA\u05D9\u05DD \u05DC\u05E2\u05D9\u05EA\u05D9\u05DD \u05E7\
  \u05E8\u05D5\u05D1\u05D5\u05EA \u05DE\u05D1\u05E6\u05E2\u05D9\u05DD \u05E4\u05E2\
  \u05D5\u05DC\u05D4 \u05D6\u05D5\u2026"
lastmod: '2024-03-13T22:44:40.092245-06:00'
model: gpt-4-0125-preview
summary: "\u05D4\u05E4\u05D9\u05DB\u05EA \u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\
  \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05E8\u05D9\u05E9\u05D9\u05D5\u05EA \u05D1\
  \u05E9\u05E4\u05EA C \u05DB\u05D5\u05DC\u05DC\u05EA \u05D4\u05DE\u05E8\u05D4 \u05E9\
  \u05DC \u05D4\u05EA\u05D5 \u05D4\u05E8\u05D0\u05E9\u05D5\u05DF \u05D1\u05DB\u05DC\
  \ \u05DE\u05D9\u05DC\u05D4 \u05D1\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05E0\u05EA\
  \u05D5\u05E0\u05D4 \u05DC\u05D0\u05D5\u05EA \u05D2\u05D3\u05D5\u05DC\u05D4, \u05D0\
  \u05DD \u05D4\u05D5\u05D0 \u05D1\u05D0\u05D5\u05EA \u05E7\u05D8\u05E0\u05D4. \u05EA\
  \u05DB\u05E0\u05EA\u05D9\u05DD \u05DC\u05E2\u05D9\u05EA\u05D9\u05DD \u05E7\u05E8\
  \u05D5\u05D1\u05D5\u05EA \u05DE\u05D1\u05E6\u05E2\u05D9\u05DD \u05E4\u05E2\u05D5\
  \u05DC\u05D4 \u05D6\u05D5\u2026"
title: "\u05D4\u05E4\u05D9\u05DB\u05EA \u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\
  \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05E8\u05D0\u05E9\u05D9\u05D5\u05EA"
---

{{< edit_this_page >}}

## מה ולמה?

הפיכת מחרוזת לאותיות רישיות בשפת C כוללת המרה של התו הראשון בכל מילה במחרוזת נתונה לאות גדולה, אם הוא באות קטנה. תכנתים לעיתים קרובות מבצעים פעולה זו במטרה לתקנן קלט משתמש עבור חיפושים, פעולות מיון או מטרות הצגה, ובכך להבטיח עקביות וקריאות לרוחב נתוני הטקסט.

## איך לעשות:

הפיכת מחרוזת לאותיות רישיות בשפת C דורשת הבנה בסיסית של מניפולציה של תווים ועיבור מחרוזות. מאחר שבשפת C אין פונקציה מובנית לכך, בדרך כלל תבדוק כל תו, ותתאים את האותיות לפי הצורך. להלן יישום פשוט:

```c
#include <stdio.h>
#include <ctype.h> // עבור הפונקציות islower ו toupper

void capitalizeString(char *str) {
    if (str == NULL) return; // בדיקת בטיחות
    
    int capNext = 1; // דגל שמציין האם להפוך את האות הבאה לאות גדולה
    for (int i = 0; str[i] != '\0'; i++) {
        if (capNext && islower(str[i])) {
            str[i] = toupper(str[i]); // הפיכת התו לאות גדולה
            capNext = 0; // איפוס הדגל
        } else if (str[i] == ' ') {
            capNext = 1; // התו הבא צריך להיות אות גדולה
        }
    }
}

int main() {
    char exampleString[] = "hello world. programming in c!";
    capitalizeString(exampleString);
    printf("Capitalized string: %s\n", exampleString);
    return 0;
}
```

פלט לדוגמה:
```
Capitalized string: Hello World. Programming In C!
```

התכנית עוברת על המחרוזת `exampleString`, בודקת כל תו אם צריך להפוך אותו לאות רישית. הפונקציה `islower` בודקת אם תו הוא אות קטנה, ו-`toupper` הופכת אותו לאות גדולה. הדגל `capNext` קובע האם האות הבאה שנתקלים בה צריכה להיות מומרת, כשהוא מוגדר לאחר כל מקום (' ') שנמצא, ובהתחלה כדי להפוך את תו הראשון של המחרוזת לאות גדולה.

## ניתוח מעמיק

השיטה שהוצגה היא פשוטה אך חסרת יעילות עבור מחרוזות גדולות מאוד או כאשר מבוצעת חוזרת באפליקציות שבהן הביצועים קריטיים. בהקשרים היסטוריים ובהקשר היישום, מניפולציית מחרוזות ב-C, כולל הפיכתן לאותיות רישיות, לעיתים קרובות כוללת יישום ישיר של ניהול באפר, משקף את הגישה הנמוכה של C ונותן למתכנת שליטה מלאה על הזיכרון ופשרות הביצועים.

ישנם שיטות אלטרנטיביות, מתקדמות יותר להפיכת מחרוזות לאותיות רישיות, במיוחד כאשר מתחשבים בלוקליזציה ותווים יוניקוד, שבהם כללי ההפיכה לאותיות גדולות יכולים להיות שונים מאוד מהסינריו הפשוט של ASCII. ספריות כמו ICU (רכיבים בינלאומיים ליוניקוד) מספקות פתרונות עמידים עבור מקרים אלו אך מצריכות תלות ועלות נוספת שלא תמיד נחוצה לכל היישומים.

בנוסף, בעוד שהדוגמה המצוינת משתמשת בפונקציות של ספריית התקן של C `islower` ו-`toupper`, שהן חלק מ-`<ctype.h>`, חשוב להבין שאלו פועלות בתחום ה-ASCII. לאפליקציות הדורשות עיבוד של תווים מחוץ ל-ASCII, כמו התמודדות עם תווים מוטעמים בשפות אירופאיות, תהיה נחוצה הגיונית נוספת או ספריות צד שלישי כדי לבצע הפיכה לאותיות רישיות באופן מדויק.

לסיכום, למרות שהשיטה המתוארת מתאימה למגוון יישומים, הבנת המגבלות שלה והאלטרנטיבות הזמינות חיונית לפיתוח תוכנה עמידה ובינלאומית בשפת C.
